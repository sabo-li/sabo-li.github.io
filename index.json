[{"content":"","date":"2025年07月05日","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"HUGO","type":"tags"},{"content":"","date":"2025年07月05日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年07月05日","externalUrl":null,"permalink":"/","section":"Sabo LI","summary":"","title":"Sabo LI","type":"page"},{"content":"","date":"2025年07月05日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025年07月05日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2/","section":"Tags","summary":"","title":"博客","type":"tags"},{"content":" 快速入门 # Hugo 是一个用 Go 编写的静态站点生成器，针对速度进行了优化，并为灵活性而设计。 凭借其先进的模板系统和快速的资源管道，Hugo 可以在几秒钟内（通常更短）渲染完成一个完整的站点。\n安装Hugo # 从源代码构建安装扩展/部署版 # 前置依赖：\nGit Dart Sass Golang CGO_ENABLED=1 go install -tags extended,withdeploy github.com/gohugoio/hugo@latest 安装成功后执行hugo version有版本输出就是安装成功了，成功示例\n$ hugo version hugo v0.147.8 darwin/amd64 BuildDate=unknown 如果编译成功，但是hugo命令找不到，需要将GOBIN环境变量添加系统环境变量中\n安装编译好的二进制版 # 参考官方安装教程 根据自己的系统类型安装二进制版\n创建一个站点 # 创建项目。\nhugo new site mywebsite 进入项目目录\ncd mywebsite 把当前目录初始化为一个空的 Git 存储库。\ngit init 本次选择使用的是 Blowfish 主题，其他主题可以参考对应的文档即可\n将 Blowfish 主题克隆到 themes 目录中，并将其作为 Git 子模块添加到项目中。\ngit submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 将.gitignore复制到项目根目录，本次只是作为参考，后续可按需自行更改。\ncp themes/blowfish/.gitignore . 复制 Blowfish 主题的配置文件到项目根目录，其他主题可参考各自的文档操作\ncp -r themes/blowfish/config ./ 在站点配置文件中追加一行，指示当前主题。\necho \u0026#34;theme = \u0026#39;blowfish\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 启动 Hugo 的开发服务器以查看站点。\nhugo server 添加一个新页面 # 在 content/posts 目录中创建 content/posts/hello-world.md\nhugo new content content/posts/hello-world.md 修改文件内容为\n+++ date = \u0026#39;2025-07-06T16:29:39+08:00\u0026#39; draft = false title = \u0026#39;Hello World\u0026#39; +++ 你好，世界！ === 访问http://localhost:1313/posts/就能看到刚创建的文章列表\nBlowfish 折腾了一些自定义配置 # 自定义为霞鹜文楷字体 # 创建layouts/partials/extend-head.html文件，并且修改文件内容为\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.css\u0026#34; media=\u0026#34;print\u0026#34; onload=\u0026#34;this.media=\u0026#39;all\u0026#39;\u0026#34;\u0026gt; 创建assets/css/custom.css文件，并且修改文件内容为\nbody, code, button { font-family: \u0026#34;LXGW WenKai Screen\u0026#34;, \u0026#34;Roboto\u0026#34;, \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft Yahei\u0026#34;, sans-serif; } 其他的一些详细配置，可以看官方文档 部署到GitHub Pages # GitHub 允许你使用 Actions 在 GitHub Pages 上托管静态网站。如果想要启用此功能，需要你在代码库中启用 Pages 并创建一个新的 Actions 工作流，以此来构建和部署你的网站。\n工作流文件需要是 YAML 格式，放置在 GitHub 仓库的 .github/workflows/ 目录下，并以 .yml 后缀命名即可。\n# .github/workflows/gh-pages.yml name: GitHub Pages on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-24.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public 将配置文件推动到 Github，Github 会自动运行工作流。你需要访问 Github 代码库的 Settings \u0026gt; Pages 部分，检查 YAML 配置是否正确。它应该被设置为使用 gh-pages 分支。\n一旦配置完成后，重新运行 Actions 工作流，网站会正确构建和部署，你就可以查看 Actions 的日志来检查是否部署成功。\n","date":"2025年07月05日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8hugo%E6%9E%84%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","section":"Posts","summary":"","title":"使用Hugo构建博客网站","type":"posts"},{"content":"","date":"2022年04月10日","externalUrl":null,"permalink":"/tags/jekyll/","section":"Tags","summary":"","title":"Jekyll","type":"tags"},{"content":" 要求 # 运行 Jekyll 需要以下条件\n1.需要 Ruby 版本 \u0026gt; 2.5.0\n2.RubyGems\n3.GCC 和 Make\n可以参考 Jekyll-Installation-Guides 根据自己环境选择安装\n安装 # 1.满足以上要求 2.安装 jekyll 和 bundler gems，如果在国内出现网络错误或者下载慢，可以使用 RubyGems 镜像 。\ngem install jekyll bundler 我在MacOS上实际执行时，出现了错误 fatal error: 'openssl/ssl.h' file not found\n可使用 以下命令解决\nbrew install openssl brew link --force openssl gem install eventmachine -- --with-cppflags=-I/usr/local/opt/openssl/include # 然后再执行 gem install jekyll 3.创建一个新的 Jekyll 站点在 ./myblog\njekyll new myblog 4.切换到新目录。\ncd myblog 5.构建站点并使其在本地服务器上可用。\nbundle exec jekyll serve 如果用的 Ruby \u0026gt;= 3.0.0，可能会出现错误 require': cannot load such file -- webrick (LoadError)，使用以下命令解决\nbundle add webrick 6.在浏览器访问 http://localhost:4000\n写文章 # 发表一篇新文章，你所需要做的就是在 /_posts 文件夹中创建一个新的文件，文件内容格式查看 Markdown 基本撰写和格式语法 。文件名的命名非常重要。Jekyll 要求一篇文章的文件名遵循下面的格式：\n年-月-日-标题.MARKUP\n下面是一些合法的文件名的例子：\n2011-12-31-new-years-eve-is-awesome.md\n2012-09-12-how-to-write-a-blog.markdown\n之前一直想从 Hexo 切换到 Jekyll，但是一看到这个格式就很别扭，每次创建文件都得敲一个日期进去，后来在Awesome (Gem-Packaged) Jekyll Plugins 发现一个很好用的插件Jekyll::Compose ，扩展了 jekyll 命令，可以非常方便创建新的文件\n添加和使用 Jekyll::Compose # 在 Gemfile 中添加：\ngem \u0026#39;jekyll-compose\u0026#39;, group: [:jekyll_plugins] 然后执行 bundle，等待执行成功后就可以使用了\n例如创建一个 _posts 文件夹中创建一个新的文章，可以使用\njekyll post 文章名字 其他用法详见 jekyll help 或者查看 Jekyll::Compose 使用说明 使用主题 # 写好文章后如果觉的页面不好看，可以切换到自己喜欢的主题，比如我首次用的就是TeXt Theme 编译和发布 # 部署到 Github # 使用的是 Github Pages，新建一个 USERNAME.github.io 源码仓库，GitHub 会自动的编译，几分钟后你就可以通过https://USERNAME.github.io访问到你的网站了。\n使用静态资源文件 # 使用以下命令编译生成静态文件，编译好的文件位于 _site 文件夹\nJEKYLL_ENV=production bundle exec jekyll build ","date":"2022年04月10日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8jekyll/","section":"Posts","summary":"","title":"基于 Ruby 3.0.0 以上版本 使用 Jekyll 4.2","type":"posts"},{"content":"","date":"2020年07月19日","externalUrl":null,"permalink":"/tags/nfs/","section":"Tags","summary":"","title":"NFS","type":"tags"},{"content":"应用程序在读取 Linux 环境使用NFS挂载的文件时，发现几Kb的文件读取时很正常，但是读取上Mb的文件时特别慢。多方搜索和询问，是因为升级内核后，需要修改同时发起的NFS请求数量即可解决问题\n原文地址 # 阿里云-如何修改同时发起的NFS请求 如何修改同时发起的NFS请求数量 # NFS客户端对于同时发起的NFS请求数量进行了控制，默认编译的内核中此参数值为2，严重影响性能，建议修改为128。本文介绍如何修改同时发起的NFS请求数量。\n您可以通过以下两种方法修改同时发起的NFS请求数量。\n说明 使用方法一修改完成后，需要重启服务器ECS，重启服务器可能影响您的业务使用。如果您不想重启服务器，可以使用方法二修改同时发起的NFS请求数量。\n方法一 # 安装NFS客户端，详情请参见安装NFS客户端 。\n执行以下命令，将同时发起的NFS请求数量修改为128。\necho \u0026#34;options sunrpc tcp_slot_table_entries=128\u0026#34; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf echo \u0026#34;options sunrpc tcp_max_slot_table_entries=128\u0026#34; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf 说明 您只需在首次安装NFS客户端后执行一次此操作（必须通过root用户操作），之后无需重复执行。\n重启云服务器ECS。\nreboot 挂载文件系统，详情请参见挂载NFS文件系统 。\n执行以下命令查看修改结果。\n如果返回值为128，则说明修改成功。\ncat /proc/sys/sunrpc/tcp_slot_table_entries 方法二 # 安装NFS客户端，详情请参见安装NFS客户端 。\n执行以下命令，将同时发起的NFS请求数量修改为128。\necho \u0026#34;options sunrpc tcp_slot_table_entries=128\u0026#34; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf echo \u0026#34;options sunrpc tcp_max_slot_table_entries=128\u0026#34; \u0026gt;\u0026gt; /etc/modprobe.d/sunrpc.conf 说明 您只需在首次安装NFS客户端后执行一次此操作（必须通过root用户操作），之后无需重复执行。\n挂载文件系统，详情请参见挂载NFS文件系统 。\n执行以下命令，再次将同时发起的NFS请求数量修改为128。\nsysctl -w sunrpc.tcp_slot_table_entries=128 卸载文件系统，详情请参见在Linux系统中卸载文件系统 。\n重新挂载文件系统，详情请参见挂载NFS文件系统 。\n执行以下命令查看修改结果。\n如果返回值为128，则说明修改成功。\ncat /proc/sys/sunrpc/tcp_slot_table_entries ","date":"2020年07月19日","externalUrl":null,"permalink":"/posts/%E8%A7%A3%E5%86%B3nfs%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E5%BC%82%E5%B8%B8/","section":"Posts","summary":"","title":"解决NFS读写文件异常","type":"posts"},{"content":"","date":"2020年07月12日","externalUrl":null,"permalink":"/tags/acme.sh/","section":"Tags","summary":"","title":"Acme.sh","type":"tags"},{"content":"","date":"2020年07月12日","externalUrl":null,"permalink":"/tags/dns/","section":"Tags","summary":"","title":"DNS","type":"tags"},{"content":"","date":"2020年07月12日","externalUrl":null,"permalink":"/tags/https/","section":"Tags","summary":"","title":"HTTPS","type":"tags"},{"content":"","date":"2020年07月12日","externalUrl":null,"permalink":"/tags/nginx/","section":"Tags","summary":"","title":"Nginx","type":"tags"},{"content":"","date":"2020年07月12日","externalUrl":null,"permalink":"/tags/%E9%85%8D%E7%BD%AE/","section":"Tags","summary":"","title":"配置","type":"tags"},{"content":" 参考地址 # acme.sh DNS API 说明 DNS API 配置 # 我用的使用阿里云 域名服务，其他可以查看使用说明 首先，需要登录到Aliyun帐户以获取API密钥 。\n然后将以下配置写入到~/.bashrc文件中，然后执行source ~/.bashrc\nexport Ali_Key=\u0026#34;获取到的阿里云DNS API Key\u0026#34; export Ali_Secret=\u0026#34;获取到的阿里云DNS API Secret\u0026#34; 安装 acme.sh # 已经安装好的请跳过\ncurl https://get.acme.sh | sh 执行颁发证书命令 # acme.sh --issue --force -d example.com -d *.example.com --dns dns_ali 将证书安装到指定位置 # acme.sh --installcert -d example.com --key-file example.com.key的路径 --fullchain-file fullchain.cer的路径 --reloadcmd \u0026#34;systemctl force-reload nginx\u0026#34; Nginx 配置 # 然后参考修改-Nginx-配置 现在想要获得 A+ 评级，需要设置 nginx 中的ssl_protocols只提供 TLSv1.2 或者更高的协议，禁用不安全或不在受支持的协议，我将原先的ssl_protocols更改为：\nssl_protocols TLSv1.2 TLSv1.3; HTTPS评级 https://myssl.com/ ","date":"2020年07月12日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8acme.sh%E7%9A%84dns-api%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E9%80%9A%E9%85%8D%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6/","section":"Posts","summary":"","title":"使用acme.sh的DNS API配置生成通配域名证书","type":"posts"},{"content":"","date":"2020年07月11日","externalUrl":null,"permalink":"/tags/gitlab/","section":"Tags","summary":"","title":"GitLab","type":"tags"},{"content":"该文档复制自Docker+k8s+GitLab+Jenkins(生产环境可CI/CD模拟) 这个环境仅做参考\n通过Docker+k8s来部署web集群，GitLab+Jenkins实现代码自动化部署，在Jenkins中通过构建脚本，实现k8s对容器web集群代码自动更新\n运行环境 # ip 服务 备注 192.168.1.1 GitLab 内存4G，双核CPU（CentOS7.8） 192.168.1.4 Jenkins 内核2G，双核CPU（CentOS7.8） 192.168.1.11 Docker+k8s-master 内核2G，双核CPU（CentOS7.8） 192.168.1.12 Docker+k8s-node1 内核2G，双核CPU（CentOS7.8） 192.168.1.13 Docker+k8s-node2 内核2G，双核CPU（CentOS7.8） 部署目的 # 在开发进行代码的更新后，上传到GitLab，Jenkins根据webhook发现代码的更新后，进行代码构建和k8s中的自动部署，展现到web界面中\n搭建GitLab # 参考文档Git搭建 和GitLab搭建 除了程序是通过yum安装的没有什么不同\n192.168.1.1 # [root@localhost ~]# hostnamectl set-hostname gitlab [root@localhost ~]# bash [root@gitlab ~]# vim /etc/hosts 192.168.1.1 gitlab 192.168.1.4 jenkins 开启路由转发\n[root@gitlab ~]# echo \u0026#34;net.ipv4.ip_forward = 1\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf [root@gitlab ~]# sysctl -p net.ipv4.ip_forward = 1 安装Git\n[root@gitlab ~]# yum -y install git 配置GitLab的repo源\n使用清华大学的repo源\n[root@gitlab ~]# cat \u0026lt;\u0026lt;EOF\u0026gt; /etc/yum.repos.d/gitlab-ce.repo [gitlab-ce] name=Gitlab CE Repository baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ gpgcheck=0 enabled=1 EOF 安装GitLab\n使用yum安装的最新版本发现对密钥问题还有点不稳定\n[root@gitlab ~]# yum -y install gitlab-ce 将 SELinux 设置为禁用，可解决设置gitlab公钥后不生效，而且还需要输入账号密码（这个问题我找了十多个小时😓）\n[root@gitlab ~]# setenforce 0 [root@gitlab ~]# sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=disabled/\u0026#39; /etc/selinux/config 生产环境中需要修改访问GitLab的域名或者ip\n[root@localhost ~]# vim /etc/gitlab/gitlab.rb # 将external_url \u0026#39;http://gitlab.example.com\u0026#39; # 修改为external_url \u0026#39;http://192.168.1.1\u0026#39;，本机域名或者ip 初始化GitLab\n[root@gitlab ~]# gitlab-ctl reconfigure # 第一次需要很长时间 启动GitLab\n[root@gitlab ~]# gitlab-ctl start 放行端口\n[root@gitlab ~]# firewall-cmd --permanent --add-service=http success [root@gitlab ~]# firewall-cmd --reload success 登陆到Web管理界面设置的登录密码\nhttp://192.168.1.1 默认用户为root\n登录成功\n搭建Jenkins # 参考文档Jenkins搭建 除了程序是通过yum安装的没有什么不同\n192.168.1.4 # [root@localhost ~]# hostnamectl set-hostname jenkins [root@localhost ~]# bash [root@jenkins ~]# vim /etc/hosts 192.168.1.1 gitlab 192.168.1.4 jenkins 192.168.1.11 k8s-master 192.168.1.12 k8s-node1 192.168.1.13 k8s-node2 准备Java环境\n使用1.8的Java环境\n[root@jenkins ~]# yum -y install java-1.8.0-openjdk* 编写Jenkins的repo源\n[root@jenkins ~]# cat \u0026lt;\u0026lt;EOF\u0026gt; /etc/yum.repos.d/jenkins.repo [jenkins] name=Jenkins-stable baseurl=https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/ gpgcheck=1 EOF # 导入rpm密钥 [root@jenkins ~]# rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 安装Jenkins\n[root@jenkins ~]# yum -y install https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.235.1-1.1.noarch.rpm [root@jenkins ~]# yum -y install git 安装加速神奇，Jenkins默认使用google来搜索插件的下载，而且插件也在国外网站，这里将updates目录中的default.json内的url换为百度（搜索引擎）和清华（下载插件地址），前提必须出现过以上界面才会有updates目录\n[root@jenkins ~]# sed -i \u0026#39;s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g\u0026#39; /var/lib/jenkins/updates/default.json [root@jenkins ~]# sed -i \u0026#39;s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g\u0026#39; /var/lib/jenkins/updates/default.json 启动Jenkins，并放行8080端口\n[root@jenkins ~]# systemctl start jenkins [root@jenkins ~]# systemctl enable jenkins [root@jenkins ~]# firewall-cmd --permanent --add-port=8080/tcp success [root@jenkins ~]# firewall-cmd --reload success 进入Jenkins的web安装界\n访问http://192.168.1.4:8080\n在Linux本地查看管理员密码\n输入密码后，如果出现此界面\n如果出现以下\n解决方法如下：\n第一步 打开插件管理的高级设置页面 http://192.168.1.4:8080/pluginManager/advanced 第二步 修改更新站点地址 将https改为http 如果不行 可以用清华的加速站点 如下 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 安装推荐插件\n然后重启服务，并重新访问Jenkins的web界面\n[root@jenkins ~]# systemctl restart jenkins 安装完成后，创建管理用户\n在插件管理中安装三个关于GitLab的插件，用于持续集成\nGitlab Authentication\nGitlab\nGitlab Hook\n选择安装后自动重启Jenkins\n搭建Kubernetes集群 # 参考本站文档Docker安装 和Kubernetes集群搭建 环境准备 # 按照运行环境中的系统版本和硬件要求\n这里使用的现成的Docker环境，没有的可以参考以上链接部署\n更改主机名 # 192.168.1.11\n更改主机名，并设置对其他两台节点的免密登录\n[root@localhost ~]# hostnamectl set-hostname k8s-master [root@localhost ~]# bash [root@k8s-master ~]# vim /etc/hosts 192.168.1.11 k8s-master 192.168.1.12 k8s-node1 192.168.1.13 k8s-node2 [root@k8s-master ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory \u0026#39;/root/.ssh\u0026#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:y0cMv9gJDShPYbfH/+WUbwtLJivwGTNv4EVT6TpxXHQ root@k8s-master The key\u0026#39;s randomart image is: +---[RSA 2048]----+ | o . o.E| | . + o o ..| | . o + o + . | | + B = + .| | . S * * .o| | o @ * . +.| | B \u0026amp;..+. +| | * o= o..| | o. . . | +----[SHA256]-----+ [root@k8s-master ~]# ssh-copy-id -i root@k8s-node1 [root@k8s-master ~]# ssh-copy-id -i root@k8s-node2 将hosts文件传输到其他两台节点\n[root@k8s-master ~]# scp /etc/hosts root@k8s-node1:/etc [root@k8s-master ~]# scp /etc/hosts root@k8s-node2:/etc 192.168.1.12\n[root@localhost ~]# hostnamectl set-hostname k8s-node1 [root@localhost ~]# bash [root@k8s-node1 ~]# 192.168.1.13\n[root@localhost ~]# hostnamectl set-hostname k8s-node2 [root@localhost ~]# bash [root@k8s-node2 ~]# 关闭沙盒 # k8s-master/node1/node2\n将 SELinux 设置为禁用（也可以设置为 permissive 模式）\n[root@k8s-master ~]# setenforce 0 [root@k8s-master ~]# sed -i \u0026#39;s/^SELINUX=enforcing$/SELINUX=disabled/\u0026#39; /etc/selinux/config 开放所需端口 # 防火墙放行端口，因为比较多，省事可以直接systemctl stop firewalld\nmaster节点\n协议 方向 端口范围 作用 使用者 TCP 入站 6443* Kubernetes API 服务器 所有组件 TCP 入站 2379-2380 etcd server client API kube-apiserver, etcd TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件 TCP 入站 10251 kube-scheduler kube-scheduler 自身 TCP 入站 10252 kube-controller-manager kube-controller-manager 自身 [root@k8s-master ~]# firewall-cmd --permanent --add-port=6443/tcp [root@k8s-master ~]# firewall-cmd --permanent --add-port=64430-64439/tcp [root@k8s-master ~]# firewall-cmd --permanent --add-port=2379-2380/tcp [root@k8s-master ~]# firewall-cmd --permanent --add-port=10250-10252/tcp [root@k8s-master ~]# firewall-cmd --reload 所有node工作节点\n协议 方向 端口范围 作用 使用者 TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件 TCP 入站 30000-32767 NodePort 服务** 所有组件 [root@k8s-node1 ~]# firewall-cmd --permanent --add-port=10250/tcp [root@k8s-node1 ~]# firewall-cmd --permanent --add-port=30000-32767/tcp [root@k8s-node1 ~]# firewall-cmd --reload 验证节点UUID # 查看每个服务器的uuid，必须不能重复\nk8s-master\n[root@k8s-master ~]# cat /sys/class/dmi/id/product_uuid E2B74D56-23A9-4E8B-620C-555387355616 关闭swap分区 # 三台节点同样的操作\n[root@k8s-master ~]# swapoff -a [root@k8s-master ~]# vim /etc/fstab # 将分区类型为swap的一行注释掉 /dev/mapper/centos-swap swap # 还是需要调整内核参数 [root@k8s-master ~]# vim /etc/sysctl.conf # 末尾添加 vm.swappiness = 0 [root@k8s-master ~]# sysctl -p 设置内核参数 # 调整iptables桥接流量，依赖于docker的启动，所以需要确保docker已经启动\nk8s-master\n[root@k8s-master ~]# vim /etc/sysctl.conf # 末尾添加 net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 [root@k8s-master ~]# sysctl -p # 为确保桥接流量不报错，执行以下命令 [root@k8s-master ~]# modprobe ip_vs_rr [root@k8s-master ~]# modprobe br_netfilter # 将修改好的文件传输到node1和node2 [root@k8s-master ~]# scp /etc/sysctl.conf root@k8s-node1:/etc [root@k8s-master ~]# scp /etc/sysctl.conf root@k8s-node2:/etc k8s-node1\n[root@k8s-node1 ~]# sysctl -p [root@k8s-node1 ~]# modprobe ip_vs_rr [root@k8s-node1 ~]# modprobe br_netfilter k8s-node2\n[root@k8s-node2 ~]# sysctl -p [root@k8s-node2 ~]# modprobe ip_vs_rr [root@k8s-node2 ~]# modprobe br_netfilter 安装Kubernetes # 编写yum源 # k8s-master\n[root@k8s-master ~]# vim /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 将yum源传给每台节点\n[root@k8s-master ~]# scp /etc/yum.repos.d/kubernetes.repo root@k8s-node1:/etc/yum.repos.d/ [root@k8s-master ~]# scp /etc/yum.repos.d/kubernetes.repo root@k8s-node2:/etc/yum.repos.d/ 安装k8s # k8s-master/node1/node2\n[root@k8s-master ~]# yum -y install kubelet kubeadm kubectl 如果有的节点在yum安装时，报错404，尝试执行rm -rf /var/cache/yum/*后，重新安装\n查看k8s版本\n[root@k8s-master ~]# kubeadm version kubeadm version: \u0026amp;version.Info{Major:\u0026#34;1\u0026#34;, Minor:\u0026#34;18\u0026#34;, GitVersion:\u0026#34;v1.18.2\u0026#34;, GitCommit:\u0026#34;52c56ce7a8272c798dbc29846288d7cd9fbae032\u0026#34;, GitTreeState:\u0026#34;clean\u0026#34;, BuildDate:\u0026#34;2020-04-16T11:54:15Z\u0026#34;, GoVersion:\u0026#34;go1.13.9\u0026#34;, Compiler:\u0026#34;gc\u0026#34;, Platform:\u0026#34;linux/amd64\u0026#34;} k8s-master\n安装kubernetes的tab快捷键，只需要在master安装即可\n[root@k8s-master ~]# yum -y install bash-completion [root@k8s-master ~]# echo \u0026#34;source \u0026lt;(kubectl completion bash)\u0026#34; \u0026gt;\u0026gt; ~/.bashrc \u0026amp;\u0026amp; bash 启动k8s # k8s-master/node1/node2\n[root@k8s-master ~]# systemctl enable --now kubelet Kubernetes集群搭建 # k8s-master\n初始化集群，完成后获取token值\n[root@k8s-master ~]# kubeadm init --apiserver-advertise-address 192.168.1.11 \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.18.2 --pod-network-cidr=10.244.0.0/16 使用管理用户（非root）执行以下操作\n[root@k8s-master ~]# mkdir -p $HOME/.kube [admin@k8s-master ~]$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config [admin@k8s-master ~]$ sudo chown $(id -u):$(id -g) $HOME/.kube/config 使用root用户执行以下操作\n[root@k8s-master ~]# echo \u0026#34;export KUBECONFIG=/etc/kubernetes/admin.conf\u0026#34; \u0026gt;\u0026gt; ~/.bashrc \u0026amp;\u0026amp; source ~/.bashrc 部署集群网络 # 下载flannel网络配置文件，有时候会下载失败，前往coreos/flannel 项目 手动将内容复制到kube-flannel.yml文件中\n[root@k8s-master ~]# curl -LO https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml # 将quay.io改为国内quay-mirror.qiniu.com [root@k8s-master ~]# sed -i s/quay.io/quay-mirror.qiniu.com/g kube-flannel.yml 然后执行以下操作\n[root@k8s-master ~]# kubectl apply -f kube-flannel.yml 节点加入集群 # 如果之前生成的token值忘了，查看kubeadm token list，还能往上翻看到token值就跳过这步\nk8s-master\n[root@k8s-master ~]# kubeadm token list TOKEN TTL EXPIRES USAGES jppmrh.1hovp0cyt4xu2w1l 23h 2020-05-11T02:05:53+08:00 authentication,signing # 将它删除重新生成 [root@k8s-master ~]# kubeadm token delete jppmrh.1hovp0cyt4xu2w1l 如果找不到了，重新生成\n[root@k8s-master ~]# kubeadm token create --print-join-command k8s-node1/node2\n[root@k8s-node1 ~]# kubeadm join 192.168.1.11:6443 --token bdsiop.8ptt7ky6t088xyl8 \\ --discovery-token-ca-cert-hash sha256:1b61fd611bd12f46c7c065995f304ad232f2a598cb99127ccc547612ea57eac0 输出信息为以下则成功\nRun \u0026#39;kubectl get nodes\u0026#39; on the control-plane to see this node join the cluster. 验证集群节点 # k8s-master\n等待一段时间，直至状态全部为Ready\n[root@k8s-master ~]# kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master Ready master 10m v1.18.2 k8s-node1 Ready \u0026lt;none\u0026gt; 3m56s v1.18.2 k8s-node2 Ready \u0026lt;none\u0026gt; 3m56s v1.18.2 集群搭建成功\n运行Docker私库—Registry # 为了在环境中更好的管理Docker镜像，决定使用Registry来运行一个容器，用来存放docker镜像，也减少了镜像存储在国外源或者国内源的传输效率，当然也能使用harbor私库代替Registry\nk8s-master\n创建镜像存放目录\n[root@k8s-master ~]# mkdir -p /data/docker/registry 下载镜像\n[root@k8s-master ~]# docker pull registry:2 运行私库容器\n[root@k8s-master ~]# docker run -itd -p 5000:5000 --restart always \\ --volume /data/docker/registry/:/var/lib/registry registry:2 查看端口是否映射成功\n[root@k8s-master ~]# netstat -anput | grep 5000 检查能否访问到私库\n[root@k8s-master ~]# firewall-cmd --permanent --add-port=5000/tcp [root@k8s-master ~]# firewall-cmd --reload [root@k8s-master ~]# curl 192.168.1.11:5000/v2/_catalog {\u0026#34;repositories\u0026#34;:[]} 设置三台docker都能识别私库地址\n[root@k8s-master ~]# vim /usr/lib/systemd/system/docker.service # 以ExecStart开头的一行的末尾添加--insecure-registry 192.168.1.11:5000 [root@k8s-master ~]# scp /usr/lib/systemd/system/docker.service root@k8s-node1:/usr/lib/systemd/system/ [root@k8s-master ~]# scp /usr/lib/systemd/system/docker.service root@k8s-node2:/usr/lib/systemd/system/ 全部重启docker\n[root@k8s-master ~]# systemctl daemon-reload \u0026amp;\u0026amp; systemctl restart docker 制作一个镜像上传到私库测试\n[root@k8s-master ~]# wget http://nginx.org/download/nginx-1.11.1.tar.gz [root@k8s-master ~]# vim Dockerfile FROM centos MAINTAINER FeiYi RUN yum -y install net-tools iproute pcre-devel openssl-devel gcc gcc-c++ make zlib-devel elinks ADD nginx-1.11.1.tar.gz /usr/src ENV NGINX_DIR /usr/src/nginx-1.11.1 WORKDIR $NGINX_DIR RUN ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install WORKDIR / RUN useradd nginx RUN ln -s /usr/local/nginx/sbin/nginx /usr/sbin/nginx EXPOSE 80 CMD [\u0026#34;nginx\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;daemon off;\u0026#34;] 构建镜像\n[root@k8s-master ~]# docker build -t 192.168.1.11:5000/bin-nginx:latest /root 上传镜像\n[root@k8s-master ~]# docker push 192.168.1.11:5000/bin-nginx [root@k8s-master ~]# curl 192.168.1.11:5000/v2/_catalog {\u0026#34;repositories\u0026#34;:[\u0026#34;bin-nginx\u0026#34;]} 私库成功\n使用k8s启动nginx容器 # k8s-master\n编写Deployment的模板文件 # [root@node1 ~]# vim nginx-deployment.yml apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: selector: matchLabels: app: nginx replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: 192.168.1.11:5000/bin-nginx ports: - containerPort: 80 运行模板文件\n[root@node1 ~]# kubectl apply -f nginx-deployment.yml deployment.apps/nginx created 查看是否运行成功\n[root@node1 ~]# kubectl get pod -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-66fb94d868-h2fkk 1/1 Running 0 2m5s 10.244.2.2 node2 nginx-66fb94d868-zhkf8 1/1 Running 0 2m5s 10.244.1.2 node3 可以看到容器的ip，现在只能在运行容器的节点才能够访问到页面内容，如果想让外部主机访问到，需要做一个service模板，用来映射端口\n编写Service模板 # 将集群中标签为app: nginx的容器的80端口映射为服务器的30001\n[root@node1 ~]# vim nginx-service.yml apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: type: NodePort ports: - port: 80 targetPort: 80 nodePort: 30001 selector: app: nginx 运行Service模板\n[root@node1 ~]# kubectl apply -f nginx-service.yml service/nginx created 访问宿主机的30001端口\nhttp://192.168.1.12:30001`和`http://192.168.1.13:30001 容器部署成功\n整合GitLab和Jenkins # Jenkins\n在Jenkins生成密钥对\n[root@jenkins ~]# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory \u0026#39;/root/.ssh\u0026#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:IITvkptc3nJrgxCxA0R0+ExWm5y/PfSIdKaQpD0NhUc root@jenkins The key\u0026#39;s randomart image is: +---[RSA 2048]----+ |++.oo.oE | |..++..=. | | .=+.Bo | | +o=.=. | | * = +S+ | | + o + O o | | . B o + + . | | + + = . | | +.o | +----[SHA256]-----+ GitLab\n登录GitLab\nhttp://192.168.1.1 创建项目仓库\n在GitLab中添加Jenkins的公钥值\n复制Jenkins服务器的公钥到下图位置，查看公钥cat .ssh/id_rsa.pub\n在GitLab的项目仓库，创建一个测试代码文件\n因为密钥上传的是Jenkins的，所以在Jenkins上下载查看\n[root@jenkins ~]# git clone http://192.168.1.1/root/nginx-test.git [root@jenkins ~]# cd nginx-test/ [root@jenkins nginx-test]# cat index.html ChaiYanjiang 成功\nJenkins\nhttp://192.168.1.4:8080/ 创建任务nginx-test\n设置源码管理时在Gitlab的地址，出现红色说明连接不到，因为GitLab已经有了Jenkins的公钥，这里只需要填写Jenkins的私钥即可\n红色报错消失了\n设置构建触发器\n当gitlab发生代码变化时，开始进行构建任务\n生成一串token值，用来对GitLab中的项目代码进行操作，所以这个值要放到GitLab中，用于验证允许Jenkins来拿取代码，稍后会将\n设置构建的命令（CI/CD）\n#!/bin/bash backupcode=/data/backupcode/$JOB_NAME/ mkdir -p $backupcode chmod 644 $JENKINS_HOME/workspace/$JOB_NAME/* rsync -acP $JENKINS_HOME/workspace/$JOB_NAME/* $backupcode echo From 192.168.1.11:5000/bin-nginx \u0026gt; $JENKINS_HOME/workspace/Dockerfile echo COPY ./nginx-test/* /usr/local/nginx/html/ \u0026gt;\u0026gt; $JENKINS_HOME/workspace/Dockerfile docker rmi 192.168.1.11:5000/bin-nginx:latest docker build -t 192.168.1.11:5000/bin-nginx:latest $JENKINS_HOME/workspace/ docker push 192.168.1.11:5000/bin-nginx:latest ssh root@k8s-master kubectl delete deployment nginx ssh root@k8s-master kubectl apply -f nginx-deployment.yml 保存即可\nGitLab\n192.168.1.1中设置Jenkins中的token值，用来触发Jenkins构建\nGitLab默认情况下不允许通过本地网络触发构建，以下这步是为了设置允许本地网络构建，如果不设置允许会在添加token时报错\n保存\n设置允许之后，就可以设置GitLab项目与Jenkins的构建触发器连接了\n进入项目中选择设置\n图中的URL是在Jenkins中的项目路径，这个路径在构建触发器的那里可以看到，复制即可，token则是刚才在Jenkins的管理界面中生成的token值，也是同样的位置，然后点击下方add webhook\nadd成功后，往下翻到如图所示位置可以看添加成功的URL，然后进行连接测试，出现200即成功\n整合Jenkins和Docker # Jenkins\n在Jenkins中做对k8s-master的免密登录，得先修改Jenkins的运行用户，这里我直接用root代替，生产环境请参考这里的scp报错部分 [root@jenkins ~]# vim /etc/sysconfig/jenkins 修改jenkins用户 JENKINS_USER=\u0026#34;jenkins\u0026#34; # 修改为root 重启Jenkins并传输密钥\n[root@jenkins ~]# systemctl restart jenkins [root@jenkins ~]# ssh-copy-id -i root@k8s-master 安装Docker，参考文档Docker安装 ，并设置镜像加速，和指定私库地址\n测试 # 修改GitLab的测试文件测试Jenkins的自动化部署是否成功\n保存后会开始自动构建部署，访问192.168.1.13:30001，如果是以下则成功，如果构建失败，则检查构建脚本，慢慢排错\n","date":"2020年07月11日","externalUrl":null,"permalink":"/posts/gitlab-jenkins-k8s-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%8F%AFci-cd%E6%A8%A1%E6%8B%9F/","section":"Posts","summary":"","title":"GitLab+Jenkins+K8S(生产环境可CI/CD模拟)","type":"posts"},{"content":"","date":"2020年07月11日","externalUrl":null,"permalink":"/tags/jenkins/","section":"Tags","summary":"","title":"Jenkins","type":"tags"},{"content":"","date":"2020年07月11日","externalUrl":null,"permalink":"/tags/k8s/","section":"Tags","summary":"","title":"K8S","type":"tags"},{"content":" 参考地址 # 使用 acme.sh 给 Nginx 安装 Let’s Encrypt 提供的免费 SSL 证书 acme.sh 说明 分享一个 HTTPS A+ 的 nginx 配置 HTTPS # 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种透过计算器网上进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。\n安装 acme.sh # curl https://get.acme.sh | sh # 重新载入 source ~/.bashrc 安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/\n生成证书 # acme.sh实现了acme协议支持的所有验证协议。 一般有两种方式验证：http和dns验证。我这里使用的是 http方式，http方式需要在你的网站根目录下放置一个文件，这个目录需要读写权限，来验证你的域名所有权，完成验证。其他方式可以参考acme.sh 生成证书 。\nacme.sh --issue -d mydomain.com -w /home/user/www/mydomain.com/ copy / 安装证书 # 注意，默认生成的证书都放在安装目录下：~/.acme.sh/，请不要直接使用此目录下的文件，例如： 不要直接让 nginx/apache的配置文件使用这下面的文件. 这里面的文件都是内部使用，而且目录结构可能会变化。\n正确的使用方法是使用--installcert命令，并指定目标位置，然后证书文件会被copy到相应的位置。\n# key-file 服务器端的 acme.sh --installcert -d mydomain.com \\ --key-file /home/user/.nginx/ssl/mydomain.com.key \\ --fullchain-file /home/user/.nginx/ssl/fullchain.cer \\ --reloadcmd \u0026#34;sudo service nginx force-reload\u0026#34; 这里用的是service nginx force-reload，不是service nginx reload，据测试，reload并不会重新加载证书，所以用的force-reload\n--installcert命令可以携带很多参数，来指定目标文件。并且可以指定reloadcmd，当证书更新以后，reloadcmd会被自动调用，让服务器生效，详细参数请参考: https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc Nginx的配置ssl_certificate使用/home/user/.nginx/ssl/fullchain.cer，而非 /home/user/.nginx/ssl/mydomain.com.cer，否则SSL Labs 的测试会报Chain issues Incomplete错误\n修改 visudo # 修改一下sudoer文件，让sudo service nginx force-reload不需要输入密码\nsudo visudo 文件内添加以下内容，user是acme.sh安装所用的账号\nuser ALL=(ALL) NOPASSWD: /usr/sbin/service nginx force-reload nano编辑器的简单使用 # 移动光标 用Ctrl+b移动到上一字符，Ctrl+f移动到下一字符 用Ctrl+p移动到上一行，Ctrl+n移动到下一行 用Ctrl+y移动到上一页，Ctrl+v移动到下一页\n保存 使用Ctrl+o来保存所做的修改，回车即可\n退出 按Ctrl+x\n其他 其中^表示Ctrl键，M表示Alt键\n使用其他编辑器 # 如果觉得nano不好用，可以设置使用其他编辑器，输入以下后，按照提示选择即可\nsudo update-alternatives --config editor 生成 dhparam.pem 文件 # openssl dhparam -out /home/user/.nginx/ssl/dhparam.pem 2048 修改 Nginx 配置 # server { listen 80; listen 443 ssl; server_name mydomain.com; # 证书文件 ssl_certificate /home/user/.nginx/ssl/fullchain.cer; # 证书私钥 ssl_certificate_key /home/user/.nginx/ssl/mydomain.com.key; # 为DHE密码指定具有DH参数的文件 ssl_dhparam /home/user/.nginx/ssl/dhparam.pem; # 开启缓存，有利于减少SSL握手开销 ssl_session_cache shared:SSL:10m; # SSL会话过期时间，有利于减少服务器开销 ssl_session_timeout 10m; # 指定可用的SSL协议 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 屏蔽不安全的加密方式 ssl_ciphers \u0026#34;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\u0026#34;; # 指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码 ssl_prefer_server_ciphers on; # 开启HSTS，强制全站加密，如果你的网站要引用不加密的资源，或者考虑将来取消加密，就不要开这个 add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubdomains; preload\u0026#34;; # ... 其他配置 } 配置好后，执行\n# 测试配置是否有问题 sudo service nginx configtest # 重启nginx服务 sudo service nginx restart 测试SSL服务 # 按照以上步骤完整配好后，应该是 A+ 测试地址：https://www.ssllabs.com/ssltest/\n后续维护 # 目前由于acme协议和letsencrypt CA都在频繁的更新, 因此acme.sh也经常更新以保持同步.\nacme.sh --upgrade # 开启自动更新 acme.sh --upgrade --auto-upgrade # 关闭自动更新 acme.sh --upgrade --auto-upgrade 0 目前证书在 60 天以后会自动更新, 需要定期重新申请，这部分acme.sh已经帮你做了，在安装的时候往 crontab增加了一行每天执行的命令，执行crontab -l，会看到以下信息\n49 0 * * * \u0026#34;/home/user/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/home/user/.acme.sh\u0026#34; \u0026gt; /dev/null 你可以尝试执行一下，看看是否正确运行\n\u0026#34;/home/user/.acme.sh\u0026#34;/acme.sh --cron --home \u0026#34;/home/user/.acme.sh\u0026#34; 最后走一下acme.sh --cron的流程看看能否正确执行\nacme.sh --cron -f ","date":"2018年10月06日","externalUrl":null,"permalink":"/posts/%E5%85%8D%E8%B4%B9%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0https%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/","section":"Posts","summary":"","title":"免费给自己的网站添加HTTPS安全加密","type":"posts"},{"content":"","date":"2018年10月01日","externalUrl":null,"permalink":"/tags/ruby/","section":"Tags","summary":"","title":"Ruby","type":"tags"},{"content":" 参考地址：Ruby 中 require,load,autoload,extend,include,prepend 的区别 load(filename, wrap=false) # =\u0026gt; true # 每次调用都会加载并执行文件文件名中的Ruby程序。如果该文件不在绝对路径中，则在$:中查找该文件。如果wrap参数为true，则加载脚本在匿名模块下执行，从而保护调用程序的全局名称空间。任何情况下，加载文件中的任何局部变量都不会加载到调用程序的环境中\nrequire(name) # =\u0026gt; true or false # 加载指定名称的文件，如果加载成功返回true, 如果已经加载返回false 如果文件不在绝对路径中，则将在$LOAD_PATH ($:)中查找 如果文件名后缀为.rb，则加载源文件。如果扩展名是当前系统平台上的二进制库文件，如.so，.o或者.dll，则Ruby会二进制库加载为Ruby扩展。否则，Ruby会尝试添加.rb，.so等直到找到为止。否则，就会触发LoadError异常 Ruby扩展名给出的文件名可以使用任何共享库扩展, 例如，在Linux上，套接字扩展名为socket.so，require \u0026quot;socket.dll\u0026quot; 将加载套接字扩展名 加载文件的路径将被添加到$LOADED_FEATURES ($\u0026quot;)中 加载的源文件中的任何常量或全局变量都将在调用程序的全局命名空间中可用\nautoload(module, filename) # =\u0026gt; nil # module通常是模块名或者类名，只有在调用模块或者类时才会加载文件\n# m.rb module M puts \u0026#39;Load M module\u0026#39; class A def self.hello puts \u0026#39;Hello\u0026#39; end end end ## require ：只加载一次 puts \u0026#34;first load: #{(require \u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; load M module #= \u0026gt; first load: true puts \u0026#34;load again: #{(require \u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; load again: false # load ：多次加载 puts \u0026#34;first load: #{(load \u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; load M module #= \u0026gt; first load: true puts \u0026#34;load again: #{(load \u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; load M module #= \u0026gt; load again: true # autoload ：调用时才加载 puts \u0026#34;first load: #{autoload(:M,\u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; first load: puts \u0026#34;load again: #{autoload(:M,\u0026#39;./m.rb\u0026#39;)}\u0026#34; #= \u0026gt; load again: M::A.hello # =\u0026gt; Load M module #= \u0026gt; Hello ","date":"2018年10月01日","externalUrl":null,"permalink":"/posts/ruby%E7%9A%84loadrequire-autoload/","section":"Posts","summary":"","title":"Ruby的load，require, autoload","type":"posts"},{"content":" include, extend, prepend # 参考地址：ruby include extend prepend 使用方法 module A def a_method puts \u0026#39;a method\u0026#39; end def self.aa_method puts \u0026#39;aa method\u0026#39; end end module B extend A end module C include A end class AA extend A end class BB include A end class CC prepend A def a_method puts \u0026#39;a method in CC\u0026#39; end end B.ancestors # =\u0026gt; [B] C.ancestors # =\u0026gt; [C, A] AA.ancestors # =\u0026gt; [AA, Object, Kernel, BasicObject] BB.ancestors # =\u0026gt; [BB, A, Object, Kernel, BasicObject] CC.ancestors # =\u0026gt; [A, CC, Object, Kernel, BasicObject] BB将新增一个类方法，AA的祖先链中没有A CC将新增一个实例方法，BB的祖先链中有A\nRuby prepend与include类似，首先都是添加实例方法的，不同的是扩展module在祖先链上的放置位置不同\n当调用方法时， Ruby是如何找到方法定义的 # 实例方法，首先在实例中查找，然后再实例对象的单件类中查找，之后沿祖先链依次向上找 类方法，首先在类的单件类中查找，然后沿着类的单件类的祖先链一次向上找（类的单件类的祖先链 = 类的祖先链的各个节点的单件类组成的链） ","date":"2018年09月30日","externalUrl":null,"permalink":"/posts/ruby%E4%B8%AD%E7%9A%84includeextend%E4%B8%8Eprepend/","section":"Posts","summary":"","title":"Ruby中的include，extend与prepend","type":"posts"},{"content":" 钩子方法提供了一种方式用于在程序运行时扩展程序的行为\n参考地址：Ruby 中一些重要的钩子方法 included # included方法是基于include的方法，可以在一些module或者class中include了一个module时它会被调用。实际在执行included之前，模块中的append_features被调用并执行具体的include操作，注意使用时不要随意覆盖Ruby的append_features方法\nmodule M def self.included(base) puts \u0026#34;#{base} included #{self}\u0026#34; end def a_method puts \u0026#34;a_method in M\u0026#34; end end class C include M end # =\u0026gt; \u0026#34;C included M\u0026#34; module O include M end # =\u0026gt; 当执行include M时，M中的included方法将会被调用，base既是执行include时包含该module的类名\nextended # 扩展(extend) 一个模块，这与 包含(include) 有点不同。 extend是将定义在 模块(module) 内的方法应用为类的方法，而不是实例的方法, extended就是extend相对应的钩子方法，注意使用时不要随意覆盖Ruby的extend_object方法\nmodule M def self.extended(base) puts \u0026#34;#{base} extended #{self}\u0026#34; end def a_method puts \u0026#34;a_method in M\u0026#34; end end class C extend M end # =\u0026gt; \u0026#34;C extended M\u0026#34; module O extend M end # =\u0026gt; \u0026#34;O extended M\u0026#34; prepended # prepend是在Ruby 2.0中引入的，并且与include和extend很不一样。 使用 include和extend引入的方法可以被目标模块/类重新定义覆盖,而prepend是不一样的，它会将prepend引入的模块 中的方法覆盖掉我们模块/类中定义的方法，prepended就是prepend的钩子方法，注意使用时不要随意覆盖Ruby的prepend_features方法\nmodule M def self.prepended(base) puts \u0026#34;#{base} prepended to #{self}\u0026#34; end def a_method puts \u0026#34;a_method in M\u0026#34; end end class C prepend M end # =\u0026gt; \u0026#34;C prepended to M\u0026#34; module O prepend M end # =\u0026gt; \u0026#34;O prepended to M\u0026#34; inherited # 继承是面向对象中一个最重要的概念。Ruby是一门面向对象的编程语言，并且提供了从基/父类继承一个子类的功能，inherited就是继承的钩子方法\nclass M def self.inherited(base) puts \u0026#34;#{base} inherits #{self}\u0026#34; end def a_method puts \u0026#34;a_method in M\u0026#34; end end class C \u0026lt; M; end # =\u0026gt; \u0026#34;C inherits M\u0026#34; method的钩子方法 # 定义，删除，取消当前类中定义的方法时会触发类或者单例类的相对应的钩子方法\nclass C def self.method_added(method_name) puts \u0026#34;Adding #{method_name.inspect}\u0026#34; end def self.method_removed(method_name) puts \u0026#34;Removing #{method_name.inspect}\u0026#34; end def self.method_undefined(method_name) puts \u0026#34;Undefined #{method_name.inspect}\u0026#34; end # 触发singleton_method_added钩子方法 def self.singleton_method_added(method_name) puts \u0026#34;Adding singleton #{method_name.inspect}\u0026#34; end # 触发singleton_method_added钩子方法 def self.singleton_method_removed(method_name) puts \u0026#34;Removing singleton #{method_name.inspect}\u0026#34; end # 触发singleton_method_added钩子方法 def self.singleton_method_undefined(method_name) puts \u0026#34;Undefined singleton #{method_name.inspect}\u0026#34; end # 触发singleton_method_added钩子方法 def self.singleton_class_method_added(); end # 触发method_added钩子方法 def class_method_added(); end # 触发singleton_method_added钩子方法 def self.singleton_class_method_removed(); end # 触发method_added钩子方法 def class_method_removed(); end # 触发singleton_method_added钩子方法 def self.singleton_class_method_undefined(); end # 触发method_added钩子方法 def class_method_undefined(); end class \u0026lt;\u0026lt; self # 触发singleton_method_removed钩子方法 remove_method :singleton_class_method_removed # 触发singleton_method_undefined钩子方法 undef_method :singleton_class_method_undefined end # 触发method_removed钩子方法 remove_method :class_method_removed # 触发method_undefined钩子方法 undef_method :class_method_undefined end # Adding singleton :singleton_method_added # Adding singleton :singleton_method_removed # Adding singleton :singleton_method_undefined # Adding singleton :singleton_class_method_added # Adding :class_method_added # Adding singleton :singleton_class_method_removed # Adding :class_method_removed # Adding singleton :singleton_class_method_undefined # Adding :class_method_undefined # Removing singleton :singleton_class_method_removed # Undefined singleton :singleton_class_method_undefined # Removing :class_method_removed # Undefined :class_method_undefined ","date":"2018年09月29日","externalUrl":null,"permalink":"/posts/ruby%E4%B8%AD%E7%9A%84%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/","section":"Posts","summary":"","title":"Ruby中的钩子方法","type":"posts"},{"content":"","date":"2018年09月28日","externalUrl":null,"permalink":"/tags/rails/","section":"Tags","summary":"","title":"Rails","type":"tags"},{"content":" 普通的mixin # module M # self.included是include时的钩子方法 def self.included(base) # base扩展 base.extend ClassMethods # 打开base，在base中执行代码 base.class_eval do # 这里写一个类include时在类需要执行什么动作 end end module ClassMethods # 这里写一个类include该module后生成的类方法 end # 这里写一个类include该module后生成的实例类方法 end 使用 ActiveSupport::Concern # require \u0026#39;active_support/concern\u0026#39; module M # 扩展当前module extend ActiveSupport::Concern # 调用Concern中定义的included方法 included do # 这里写一个类include时在类需要执行什么动作 end # 调用Concern中定义的class_methods方法 class_methods do # 这里写一个类include该module后生成的类方法 end # 这里写一个类include该module后生成的实例类方法 end 解读 ActiveSupport::Concern # module ActiveSupport module Concern # 定义了一个异常类，不能多次include class MultipleIncludedBlocks \u0026lt; StandardError def initialize super \u0026#34;Cannot define multiple \u0026#39;included\u0026#39; blocks for a Concern\u0026#34; end end # self.extended是extend时的钩子方法 def self.extended(base) # 定义base中的@_dependencies base.instance_variable_set(:@_dependencies, []) end # ruby在include一个module时会调用append_features方法，进行实际的mixin操作，包括增加常量，方法和变量到模块中 def append_features(base) if base.instance_variable_defined?(:@_dependencies) # 如果有引入已经定义@_dependencies时，一般是引入一个已经extend这个Concern的module，才会定义@_dependencies # 将后extend这个Concern的module放入到@_dependencies中 base.instance_variable_get(:@_dependencies) \u0026lt;\u0026lt; self false else return false if base \u0026lt; self # @_dependencies是详见上面定义的self.extended # 先引入包含在@_dependencies中module @_dependencies.each { |dep| base.include(dep) } super # ClassMethods是详见下面定义的class_methods # 如果定义ClassMethods,将ClassMethods中的方法extend到base中 base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods) # @_included_block是详见下面定义的included方法 # 如果定义@_included_block,在base中执行@_included_block中的代码 base.class_eval(\u0026amp;@_included_block) if instance_variable_defined?(:@_included_block) end end # extend后，将可以使用included这个方法 def included(base = nil, \u0026amp;block) if base.nil? # 判断是否多次include raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block) # 定义类实例类变量 @_included_block = block else super end end # extend后，将可以使用class_methods这个方法 def class_methods(\u0026amp;class_methods_module_definition) # extend时判断当前module是否定义了ClassMethods这个常量，不包括父级 # 有的话就使用已经定义好的，没有就Module.new一个 mod = const_defined?(:ClassMethods, false) ? const_get(:ClassMethods) : const_set(:ClassMethods, Module.new) # extend后，调用class_methods方时将块里的定写入到ClassMethods里 mod.module_eval(\u0026amp;class_methods_module_definition) end end end ","date":"2018年09月28日","externalUrl":null,"permalink":"/posts/rails%E4%B8%AD%E7%9A%84activesupport-concern/","section":"Posts","summary":"","title":"Rails中的ActiveSupport::Concern","type":"posts"},{"content":"原文地址 对条件 GET 请求的支持 # 条件 GET 请求是 HTTP 规范的一个特性，以此告诉 Web 浏览器，GET 请求的响应自上次请求之后没有变化，可以放心从浏览器的缓存中读取。\n为此，要传递HTTP_IF_NONE_MATCH和 HTTP_IF_MODIFIED_SINCE首部，其值分别为唯一的内容标识符和上一次改动时的时间戳。浏览器发送的请求，如果内容标识符（etag）或上一次修改的时间戳与服务器中的版本匹配，那么服务器只需返回一个空响应，把状态设为未修改。\n服务器（也就是我们自己）要负责查看最后修改时间戳和HTTP_IF_NONE_MATCH首部，判断要不要返回完整的响应。既然 Rails 支持条件 GET 请求，那么这个任务就非常简单：\nclass ProductsController \u0026lt; ApplicationController def show @product = Product.find(params[:id]) # 如果根据指定的时间戳和 etag 值判断请求的内容过期了 # （即需要重新处理）执行这个块 if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key) respond_to do |wants| # ... 正常处理响应 end end # 如果请求的内容还新鲜（即未修改），无需做任何事 # render 默认使用前面 stale? 中的参数做检查，会自动发送 :not_modified 响应 # 就这样，工作结束 end end 除了散列，还可以传入模型。Rails 会使用updated_at和 cache_key方法设定last_modified和etag：\nclass ProductsController \u0026lt; ApplicationController def show @product = Product.find(params[:id]) if stale?(@product) respond_to do |wants| # ... 正常处理响应 end end end end 如果无需特殊处理响应，而且使用默认的渲染机制（即不使用respond_to，或者不自己调用render），可以使用 fresh_when简化这个过程：\nclass ProductsController \u0026lt; ApplicationController # 如果请求的内容是新鲜的，自动返回 :not_modified # 否则渲染默认的模板（product.*） def show @product = Product.find(params[:id]) fresh_when last_modified: @product.published_at.utc, etag: @product end end 有时，我们需要缓存响应，例如永不过期的静态页面。为此，可以使用 http_cache_forever辅助方法，让浏览器和代理无限期缓存。\n默认情况下，缓存的响应是私有的，只在用户的 Web 浏览器中缓存。如果想让代理缓存响应，设定public: true，让代理把缓存的响应提供给所有用户。\n使用这个辅助方法时，last_modified首部的值被设为Time.new(2011, 1, 1).utc，expires首部的值被设为 100 年。\n使用这个方法时要小心，因为浏览器和代理不会作废缓存的响应，除非强制清除浏览器缓存。\nclass HomeController \u0026lt; ApplicationController def index http_cache_forever(public: true) do render end end end 强 Etag 与弱 Etag # Rails 默认生成弱 ETag。这种 Etag 允许语义等效但主体不完全匹配的响应具有相同的 Etag。如果响应主体有微小改动，而不想重新渲染页面，可以使用这种 Etag。\n为了与强 Etag 区别，弱 Etag 前面有W/。\nW/\u0026#34;618bbc92e2d35ea1945008b42799b0e7\u0026#34; # =\u0026gt; 弱 ETag \u0026#34;618bbc92e2d35ea1945008b42799b0e7\u0026#34; # =\u0026gt; 强 ETag 与弱 Etag 不同，强 Etag 要求响应完全一样，不能有一个字节的差异。在大型视频或 PDF 文件内部做 Range 查询时用得到。有些 CDN，如 Akamai，只支持强 Etag。如果确实想生成强 Etag，可以这么做：\nclass ProductsController \u0026lt; ApplicationController def show @product = Product.find(params[:id]) fresh_when last_modified: @product.published_at.utc, strong_etag: @product end end 也可以直接在响应上设定强 Etag：\nresponse.strong_etag = response.body # =\u0026gt; \u0026#34;618bbc92e2d35ea1945008b42799b0e7\u0026#34; ","date":"2018年09月27日","externalUrl":null,"permalink":"/posts/rails%E5%AF%B9http%E6%9D%A1%E4%BB%B6get%E8%AF%B7%E6%B1%82%E7%9A%84%E6%94%AF%E6%8C%81/","section":"Posts","summary":"","title":"Rails对HTTP条件GET请求的支持","type":"posts"},{"content":" Rails 为存储缓存数据（SQL 缓存和页面缓存除外）提供了不同的存储器。\n原文地址 配置 # config.cache_store 配置选项用于设定应用的默认缓存存储器。可以设定其他参数，传给缓存存储器的构造方法\nconfig.cache_store = :memory_store, { size: 64.megabytes } 此外，还可以在配置块外部调用 ActionController::Base.cache_store。\n缓存存储器通过 Rails.cache 访问。\nActiveSupport::Cache::Store # 这个类是在 Rails 中与缓存交互的基础。这是个抽象类，不能直接使用。你必须根据存储器引擎具体实现这个类。Rails 提供了几个实现，说明如下。\n主要调用的方法有read、write、delete、exist?和fetch。fetch方法接受一个块，返回缓存中现有的值，或者把新值写入缓存。\n所有缓存实现有些共用的选项，可以传给构造方法，或者传给与缓存条目交互的各个方法。\n:namespace：在缓存存储器中创建命名空间。如果与其他应用共用同一个缓存存储器，这个选项特别有用。 :compress：指定压缩缓存。通过缓慢的网络传输大量缓存时用得着。 :compress_threshold：与 :compress选项搭配使用，指定一个阈值，未达到时不压缩缓存。默认为16千字节。 :expires_in：为缓存条目设定失效时间（秒数），失效后自动从缓存中删除。 :race_condition_ttl：与 :expires_in选项搭配使用。避免多个进程同时重新生成相同的缓存条目（也叫 dog pile effect），防止让缓存条目过期时出现条件竞争。这个选项设定在重新生成新值时失效的条目还可以继续使用多久（秒数）。如果使用 :expires_in 选项，最好也设定这个选项。 自定义缓存存储器 # 缓存存储器可以自己定义，只需扩展ActiveSupport::Cache::Store类，实现相应的方法。这样，你可以把任何缓存技术带到你的 Rails 应用中。\n若想使用自定义的缓存存储器，只需把cache_store设为自定义类的实例：\nconfig.cache_store = MyCacheStore.new ActiveSupport::Cache::MemoryStore # 这个缓存存储器把缓存条目放在内存中，与 Ruby 进程放在一起。可以把:size选项传给构造方法，指定缓存的大小限制（默认为32Mb）。超过分配的大小后，会清理缓存，把最不常用的条目删除。\nconfig.cache_store = :memory_store, { size: 64.megabytes } 如果运行多个 Ruby on Rails 服务器进程（例如使用 Phusion Passenger 或 Puma 集群模式），各个实例之间无法共享缓存数据。这个缓存存储器不适合大型应用使用。不过，适合只有几个服务器进程的低流量小型应用使用，也适合在开发环境和测试环境中使用\nActiveSupport::Cache::FileStore # 这个缓存存储器使用文件系统存储缓存条目。初始化这个存储器时，必须指定存储文件的目录：\nconfig.cache_store = :file_store, \u0026#34;/path/to/cache/directory\u0026#34; 使用这个缓存存储器时，在同一台主机中运行的多个服务器进程可以共享缓存。这个缓存存储器适合一到两个主机的中低流量网站使用。运行在不同主机中的多个服务器进程若想共享缓存，可以使用共享的文件系统，但是不建议这么做。\n缓存量一直增加，直到填满磁盘，所以建议你定期清理旧缓存条目。\n这是默认的缓存存储器\nActiveSupport::Cache::MemCacheStore # 这个缓存存储器使用 Danga 的memcached服务器为应用提供中心化缓存。Rails 默认使用自带的dalli gem。这是生产环境的网站目前最常使用的缓存存储器。通过它可以实现单个共享的缓存集群，效率很高，有较好的冗余。\n初始化这个缓存存储器时，要指定集群中所有memcached服务器的地址。如果不指定，假定 memcached运行在本地的默认端口上，但是对大型网站来说，这样做并不好。\n这个缓存存储器的write和fetch方法接受两个额外的选项，以便利用memcached的独有特性。指定:raw时，直接把值发给服务器，不做序列化。值必须是字符串或数字。memcached的直接操作，如increment和decrement，只能用于原始值。还可以指定:unless_exist选项，不让memcached覆盖现有条目。\nconfig.cache_store = :mem_cache_store, \u0026#34;cache-1.example.com\u0026#34;, \u0026#34;cache-2.example.com\u0026#34; ActiveSupport::Cache::NullStore # 这个缓存存储器只应该在开发或测试环境中使用，它并不存储任何信息。在开发环境中，如果代码直接与Rails.cache 交互，但是缓存可能对代码的结果有影响，可以使用这个缓存存储器。在这个缓存存储器上调用fetch和read方法不返回任何值。\nconfig.cache_store = :null_store 缓存键 # 缓存中使用的键可以是能响应cache_key或 to_param方法的任何对象。如果想定制生成键的方式，可以覆盖cache_key方法。Active Record 根据类名和记录 ID 生成缓存键。\n缓存键的值可以是散列或数组：\n# 这是一个有效的缓存键 Rails.cache.read(site: \u0026#34;mysite\u0026#34;, owners: [owner_1, owner_2]) Rails.cache使用的键与存储引擎使用的并不相同，存储引擎使用的键可能含有命名空间，或者根据后端的限制做调整。这意味着，使用Rails.cache存储值时使用的键可能无法用于供 dalli gem 获取缓存条目。然而，你也无需担心会超出memcached的大小限制，或者违背句法规则\n","date":"2018年09月26日","externalUrl":null,"permalink":"/posts/rails%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8/","section":"Posts","summary":"","title":"Rails缓存存储器","type":"posts"},{"content":"更多详细查看原文地址 片段缓存 # 动态 Web 应用一般使用不同的组件构建页面，不是所有组件都能使用同一种缓存机制。如果页面的不同部分需要使用不同的缓存机制，在不同的条件下失效，可以使用片段缓存（ActionView::Helpers::CacheHelper#cache）。片段缓存把视图逻辑的一部分放在 cache 块中，下次请求使用缓存存储器中的副本伺服\n使用 # 如果想缓存页面中的各个商品，可以使用下述代码：\n\u0026lt;% @products.each do |product| %\u0026gt; \u0026lt;% cache product do %\u0026gt; \u0026lt;%= render product %\u0026gt; \u0026lt;% end %\u0026gt; \u0026lt;% end %\u0026gt; 首次访问这个页面时，Rails 会创建一个具有唯一键的缓存条目。缓存键类似下面这种\nviews/products/1-201505056193031061005000/bea67108094918eeba42cd4a6e786901 中间的数字是 product_id 加上商品记录的 updated_at 属性中存储的时间戳。Rails 使用时间戳确保不伺服过期的数据。如果 updated_at 的值变了，Rails 会生成一个新键，然后在那个键上写入一个新缓存，旧键上的旧缓存不再使用。这叫基于键的失效方式\n视图片段有变化时（例如视图的 HTML 有变），缓存的片段也失效。缓存键末尾那个字符串是模板树摘要，是基于缓存的视图片段的内容计算的 MD5 哈希值。如果视图片段有变化，MD5 哈希值就变了，因此现有文件失效\nMemcached 等缓存存储器会自动删除旧的缓存文件\n特定条件下缓存一个片段，可以使用 cache_if 或 cache_unless\n\u0026lt;% cache_if admin?, product do %\u0026gt; \u0026lt;%= render product %\u0026gt; \u0026lt;% end %\u0026gt; render 辅助方法还能缓存渲染集合的单个模板。这甚至比使用 each 的前述示例更好，因为是一次性读取所有缓存模板的，而不是一次读取一个。若想缓存集合，渲染集合时传入 cached: true 选项\n\u0026lt;%= render partial: \u0026#39;products/product\u0026#39;, collection: @products, cached: true %\u0026gt; 上述代码中所有的缓存模板一次性获取，速度更快。此外，尚未缓存的模板也会写入缓存，在下次渲染时获取\n俄罗斯套娃缓存 # 有时，可能想把缓存的片段嵌套在其他缓存的片段里。这叫俄罗斯套娃缓存（Russian doll caching） 俄罗斯套娃缓存的优点是，更新单个商品后，重新生成外层片段时，其他内存片段可以复用 前一节说过，如果缓存的文件对应的记录的 updated_at 属性值变了，缓存的文件失效。但是，内层嵌套的片段不失效\n\u0026lt;% cache product do %\u0026gt; \u0026lt;%= render product.games %\u0026gt; \u0026lt;% end %\u0026gt; 上面这个会渲染下面这个\n\u0026lt;% cache game do %\u0026gt; \u0026lt;%= render game %\u0026gt; \u0026lt;% end %\u0026gt; 如果游戏的任何一个属性变了，updated_at 的值会设为当前时间，因此缓存失效。然而，商品对象的 updated_at 属性不变，因此它的缓存不失效，从而导致应用伺服过期的数据。为了解决这个问题，可以使用 touch 方法把模型绑在一起\nclass Product \u0026lt; ApplicationRecord has_many :games end class Game \u0026lt; ApplicationRecord belongs_to :product, touch: true end 管理依赖 # 为了正确地让缓存失效，要正确地定义缓存依赖。Rails 足够智能，能处理常见的情况，无需自己指定。但是有时需要处理自定义的辅助方法（以此为例），因此要自行定义\n隐式依赖 # 多数模板依赖可以从模板中的 render 调用中推导出来。下面举例说明 ActionView::Digestor 知道如何解码的 render 调用\nrender partial: \u0026#34;comments/comment\u0026#34;, collection: commentable.comments render \u0026#34;comments/comments\u0026#34; render \u0026#39;comments/comments\u0026#39; render(\u0026#39;comments/comments\u0026#39;) render \u0026#34;header\u0026#34; =\u0026gt; render(\u0026#34;comments/header\u0026#34;) render(@topic) # =\u0026gt; render(\u0026#34;topics/topic\u0026#34;) render(topics) # =\u0026gt; render(\u0026#34;topics/topic\u0026#34;) render(message.topics) # =\u0026gt; render(\u0026#34;topics/topic\u0026#34;) 而另一方面，有些调用要做修改方能让缓存正确工作。例如，如果传入自定义的集合，要把下述代码：\nrender @project.documents.where(published: true) 改为\nrender partial: \u0026#34;documents/document\u0026#34;, collection: @project.documents.where(published: true) 显式依赖 # 有时，模板依赖推导不出来。在辅助方法中渲染时经常是这样\n\u0026lt;%= render_sortable_todolists @project.todolists %\u0026gt; 此时，要使用一种特殊的注释格式：\n\u0026lt;%# Template Dependency: todolists/todolist %\u0026gt; \u0026lt;%= render_sortable_todolists @project.todolists %\u0026gt; 某些情况下，例如设置单表继承，可能要显式定义一堆依赖。此时无需写出每个模板，可以使用通配符匹配一个目录中的全部模板：\n\u0026lt;%# Template Dependency: events/* %\u0026gt; \u0026lt;%= render_categorizable_events @person.events %\u0026gt; 对集合缓存来说，如果局部模板不是以干净的缓存调用开头，依然可以使用集合缓存，不过要在模板中的任意位置添加一种格式特殊的注释，如下所示：\n\u0026lt;%# Template Collection: notification %\u0026gt; \u0026lt;% my_helper_that_calls_cache(some_arg, notification) do %\u0026gt; \u0026lt;%= notification.name %\u0026gt; \u0026lt;% end %\u0026gt; 外部依赖 # 如果在缓存的块中使用辅助方法，而后更新了辅助方法，还要更新缓存。具体方法不限，只要能改变模板文件的 MD5 值就行。推荐的方法之一是添加一个注释，如下所示：\n\u0026lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %\u0026gt; \u0026lt;%= some_helper_method(person) %\u0026gt; 低层缓存 # 有时需要缓存特定的值或查询结果，而不是缓存视图片段。Rails 的缓存机制能存储任何类型的信息。\n实现低层缓存最有效的方式是使用 Rails.cache.fetch 方法。这个方法既能读取也能写入缓存。传入单个参数时，获取指定的键，返回缓存中的值。如果传入块，块中的代码在缓存缺失时执行。块返回的值将写入缓存，存在指定键的名下，然后返回那个返回值。如果命中缓存，直接返回缓存的值，而不执行块中的代码。\n下面举个例子。应用中有个 Product 模型，它有个实例方法，在竞争网站中查找商品的价格。这个方法返回的数据特别适合使用低层缓存：\nclass Product \u0026lt; ApplicationRecord def competing_price Rails.cache.fetch(\u0026#34;#{cache_key}/competing_price\u0026#34;, expires_in: 12.hours) do Competitor::API.find_price(id) end end end 注意，这个示例使用了 cache_key 方法，因此得到的缓存键类似这种：products/233-20140225082222765838000/competing_price。cache_key 方法根据模型的 id 和 updated_at 属性生成一个字符串。这是常见的约定，有个好处是，商品更新后缓存自动失效。一般来说，使用低层缓存缓存实例层信息时，需要生成缓存键。\nSQL 缓存 # 查询缓存是 Rails 提供的一个功能，把各个查询的结果集缓存起来。如果在同一个请求中遇到了相同的查询，Rails 会使用缓存的结果集，而不再次到数据库中运行查询。\n例如：\nclass ProductsController \u0026lt; ApplicationController def index # 运行查找查询 @products = Product.all ... # 再次运行相同的查询 @products = Product.all end end 再次运行相同的查询时，根本不会发给数据库。首次运行查询得到的结果存储在查询缓存中（内存里），第二次查询从内存中获取。\n然而要知道，查询缓存在动作开头创建，到动作末尾销毁，只在动作的存续时间内存在。如果想持久化存储查询结果，使用低层缓存也能实现\n","date":"2018年09月25日","externalUrl":null,"permalink":"/posts/rails%E7%89%87%E6%AE%B5%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BC%93%E5%AD%98/","section":"Posts","summary":"","title":"Rails片段缓存以及其他缓存","type":"posts"},{"content":" 动作缓存 # 有前置过滤器的动作不能使用页面缓存，例如需要验证身份的页面。此时，应该使用动作缓存。动作缓存的工作原理与页面缓存类似，不过入站请求会经过 Rails 栈处理，以便运行前置过滤器，然后再伺服缓存。这样，可以做身份验证和其他限制，同时还能从缓存的副本中伺服结果。\n动作缓存已从Rails 4中删除\n动作缓存actionpack-action_caching的地址 安装 # 在Rails项目中的Gemfile文件中添加\ngem \u0026#39;actionpack-action_caching\u0026#39; 然后执行bundle install命令安装\n使用 # 详细介绍查看动作缓存actionpack-action_caching class ListsController \u0026lt; ApplicationController before_action :authenticate, except: :public caches_page :public caches_action :index, :show end class ListsController \u0026lt; ApplicationController before_action :authenticate, except: :public # simple fragment cache caches_action :current # expire cache after an hour caches_action :archived, expires_in: 1.hour # cache unless it\u0026#39;s a JSON request caches_action :index, unless: -\u0026gt; { request.format.json? } # custom cache path caches_action :show, cache_path: { project: 1 } # custom cache path with a proc caches_action :history, cache_path: -\u0026gt; { request.domain } # custom cache path with a symbol caches_action :feed, cache_path: :user_cache_path protected def user_cache_path if params[:user_id] user_list_url(params[:user_id], params[:id]) else list_url(params[:id]) end end end ","date":"2018年09月24日","externalUrl":null,"permalink":"/posts/rails%E5%8A%A8%E4%BD%9C%E7%BC%93%E5%AD%98/","section":"Posts","summary":"","title":"Rails动作缓存","type":"posts"},{"content":" 页面缓存 # 页面缓存是 Rails 提供的一种缓存机制，让 Web 服务器（如 Apache 和 NGINX）直接访问静态页面，而不经由 Rails 动态生成。虽然这种缓存的速度超快，但是不适用于所有情况（例如需要验证身份的页面）。此外，因为 Web 服务器直接从文件系统中访问文件，所以要自行实现缓存失效机制\n页面缓存已从Rails 4中删除\n页面缓存actionpack-page_caching的地址 安装 # 在Rails项目中的Gemfile文件中添加\ngem \u0026#39;actionpack-page_caching\u0026#39; 然后执行bundle install命令安装\n设置 # 设置缓存文件存放位置page_cache_directory\nconfig.action_controller.page_cache_directory = \u0026#34;#{Rails.root}/public/cached_pa​​ges\u0026#34; 也可以给Controller单独设置，可以使用以下三种方式\n指向一个lambda表达式，运行时会自动调用lambda的call方法\nclass WeblogController \u0026lt; ApplicationController self.page_cache_directory = -\u0026gt; { Rails.root.join(\u0026#34;public\u0026#34;, request.domain) } end 也可指向一个方法的symbol名\nclass WeblogController \u0026lt; ApplicationController self.page_cache_directory = :domain_cache_directory private def domain_cache_directory Rails.root.join(\u0026#34;public\u0026#34;, request.domain) end end 也可以指向实现call类方法的对象\nclass DomainCacheDirectory def self.call(request) Rails.root.join(\u0026#34;public\u0026#34;, request.domain) end end class WeblogController \u0026lt; ApplicationController self.page_cache_directory = DomainCacheDirectory end 使用 # 设置 # class WeblogController \u0026lt; ActionController::Base caches_page :show, :new # 设置new和show页面缓存 # 生成public/cached_pa​​ges/weblog/new.html def new @list = List.new end # 生成public/cached_pa​​ges/weblog/:id.html def show @list = List.find(params[:id]) end end 更新页面缓存 # 数据更新后，将已生成的页面缓存过期\nclass WeblogController \u0026lt; ActionController::Base def update List.update(params[:list][:id], params[:list]) # 设置public/cached_pa​​ges/weblog/:id.html已过期 expire_page action: \u0026#39;show\u0026#39;, id: params[:list][:id] # 跳转到show，生成新的public/cached_pa​​ges/weblog/:id.html redirect_to action: \u0026#39;show\u0026#39;, id: params[:list][:id] end end Nginx配置 # 如果页面缓存文件存在，将页面缓存作为响应内容返回\n# Index HTML Files if (-f $document_root/cached_pa​​ges/$uri/index.html) { rewrite (.*) /cached_pa​​ges/$1/index.html break; } # Other HTML Files if (-f $document_root/cached_pa​​ges/$uri.html) { rewrite (.*) /cached_pa​​ges/$1.html break; } # All if (-f $document_root/cached_pa​​ges/$uri) { rewrite (.*) /cached_pa​​ges/$1 break; } ","date":"2018年09月23日","externalUrl":null,"permalink":"/posts/rails%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/","section":"Posts","summary":"","title":"Rails页面缓存","type":"posts"},{"content":"","date":"2018年09月22日","externalUrl":null,"permalink":"/tags/gogs/","section":"Tags","summary":"","title":"Gogs","type":"tags"},{"content":"","date":"2018年09月22日","externalUrl":null,"permalink":"/tags/%E9%83%A8%E7%BD%B2/","section":"Tags","summary":"","title":"部署","type":"tags"},{"content":" Gogs 是一款极易搭建的自助 Git 服务。\n为什么选择Gogs # 我之前也部署过Gitlab，但是太吃资源了，Gogs相比就很轻量，正好合适搭建私人Git服务器。\n安装Nginx和数据库 # 要部署Gogs，需要安装Nginx和数据库\n安装Nginx\nsudo apt-get update sudo apt-get install nginx 安装和初始化数据库 # Gogs支持MySQL，PostgreSQL，SQLite3，MSSQL和TiDB，这里我选择PostgreSQL\nsudo apt-get update sudo apt-get install postgresql 命令执行完毕后，配置数据库\n设置密码 # 安装完毕后需要更改postgres用户的密码，否则就没法使用这个数据库服务器。以postgres这个系统用户的身份运行psql命令\nsudo -u postgres psql 进入psql命令接口\nALTER USER postgres WITH PASSWORD \u0026#39;这里写postgres用户的新密码\u0026#39;; 执行完毕后，\\q退出\n创建PostgreSQL的新用户和数据库 # # -D 没有创建数据库的权限 # -A 没有新建用户的权限 # -P 为新用户设置密码 sudo -u postgres createuser -D -A -P gogs # 创建用户时会提示你输入密码 # 创建一个数据库gogs-db，以 gogs 作为它的所有者 sudo -u postgres createdb -O gogs gogs-db 安装Gogs # 创建新用户 # 为什么创建一个新的用户呢？之前我也一直在纠结。后来，发生了密钥冲突，这个就是因为管理员密钥月Gogs运行应用的用户密钥一样所导致的，如果Gogs运行应用的用户不是管理员也就不会有这个情况了\nuseradd -m git # 切换到git用户 sudo su git # 切换到git用户的HOME目录 cd ~ 下面操作都是在git用户下操作\n下载Gogs程序 # 我使用的是Gogs二进制安装包 ，下载的是Linux，64位，TAR.GZ，可以用curl或者wget下载文件\n示例\n# 使用curl curl -O https://dl.gogs.io/0.11.66/gogs_0.11.66_linux_amd64.tar.gz # 使用 wget wget https://dl.gogs.io/0.11.66/gogs_0.11.66_linux_amd64.tar.gz 解压\ntar -zxvf gogs_0.11.66_linux_amd64.tar.gz 启动Gogs服务 # cd gogs ./gogs web 然后再浏览器输入IP:3000，端口号默认是3000，这个时候进入应该进入的是/install，具体就是一些Gogs程序的基本设置，填完提交后，进入命令行按ctl+c结束程序，就可以进行下一步了\nGogs守护进程 # 这部分主要修改Gogs项目中的scripts里的文件，以下文件请根据实际情况做修改\nvim scripts/init/debian/gogs #! /bin/sh ### BEGIN INIT INFO # Provides: gogs # Required-Start: $syslog $network # Required-Stop: $syslog # Should-Start: mysql postgresql # Should-Stop: mysql postgresql # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: A self-hosted Git service written in Go. # Description: A self-hosted Git service written in Go. ### END INIT INFO # Author: Danny Boisvert # Do NOT \u0026#34;set -e\u0026#34; # PATH should only include /usr/* if it runs after the mountnfs.sh script PATH=/sbin:/usr/sbin:/bin:/usr/bin DESC=\u0026#34;Gogs\u0026#34; NAME=gogs SERVICEVERBOSE=yes PIDFILE=/var/run/$NAME.pid SCRIPTNAME=/etc/init.d/$NAME WORKINGDIR=/home/git/gogs # 这是Gogs运行应用的项目路径 DAEMON=$WORKINGDIR/$NAME DAEMON_ARGS=\u0026#34;web\u0026#34; USER=git # 这是Gogs运行应用的用户 # 以下不做修改 然后退出，接着修改下一个文件\nvim scripts/systemd/gogs.service [Unit] Description=Gogs After=syslog.target After=network.target # 修改这里，如果用到其他服务的话 # After=mariadb.service mysqld.service postgresql.service memcached.service redis.service # 我这只用到了postgresql After=postgresql.service [Service] Type=simple User=git # 这是Gogs运行应用的用户 Group=git # 该用户的组 WorkingDirectory=/home/git/gogs # 这是Gogs运行应用的项目路径 # /home/git/gogs/gogs这是Gogs运行应用程序的位置 ExecStart=/home/git/gogs/gogs web Restart=always # Environment=USER后是Gogs运行应用的用户 # HOME是该用户的HOME路径 Environment=USER=git HOME=/home/git # 以下不做修改 修改完之后，软连接文件到相应位置\n# 退出git用户，切到管理员 exit sudo ln -s /home/git/gogs/scripts/init/debian/gogs /etc/init.d/gogs sudo ln -s /home/git/gogs/scripts/systemd/gogs.service /etc/systemd/system/gogs.service 然后就可以使用service命令来管理Gogs的服务状态了\n# 例如，启动gogs服务 sudo service gogs start Nginx反向代理Gogs服务 # 只需要在Nginx配置里新引入一个server就可以了\nserver { listen 80; # 端口号 server_name gogs.example.com; # 域名 location / { proxy_pass http://localhost:3000; # Gogs 服务地址 } } 添加完后，执行sudo nginx -t查看是否有误，然后使用sudo nginx -s reload重载Nginx，就可以了\n","date":"2018年09月22日","externalUrl":null,"permalink":"/posts/%E5%9C%A8ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2gogs/","section":"Posts","summary":"","title":"在Ubuntu上部署Gogs","type":"posts"},{"content":" 错误描述：fatal: 'XX/XX.git' does not appear to be a git repository\n问题 # 部署完Gogs后，在Web页面创建好仓库后，本地向远程推送出现无法读取远程仓库的问题，可能原因：~/.ssh/authorized_keys 文件中存在重复的 SSH 密钥，所以公钥使用冲突 了\n解决方案 # 删除~/.ssh/authorized_keys文件里除了属于 Gogs 自动添加以外的重复密钥，这样就可以正常了\n新的问题 # 但是这样又出现了个新的问题，就是我用ssh登不上我的远程服务器了，原来刚刚删除的那个秘钥是ssh远程登录密钥，这样可不行的呀\n新的方案 # 额外再生成一个新的密钥id_rsa_gogs\nssh-keygen -t rsa -C \u0026#39;邮箱或者其他标识\u0026#39; -f ~/.ssh/id_rsa_gogs 再在本地新建（如果存在就修改）~/.ssh/config添加以下内容\nHost gogs HostName example.com # IP地址或者域名 Port 222 # ssh端口号 User git # 远程服务器的用户名 IdentityFile ~/.ssh/id_rsa_gogs # 刚才生成的密钥的路径 IdentitiesOnly Yes # 只使用这里设置的key 然后就可以使用gogs这个别名来代替user@host:222了\n# 以前仓库地址为 user@host:222/repositories-path/xxx.git # 改为现在的地址 gogs:/repositories-path/xxx.git 这样就OK了，看看其他方案 ","date":"2018年09月21日","externalUrl":null,"permalink":"/posts/gogs%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93fatal-xx-xx-git-does-not-appear-to-be-a-git-repository/","section":"Posts","summary":"","title":"Gogs无法读取远程仓库（fatal: XX/XX.git does not appear to be a git repository）","type":"posts"},{"content":"","date":"2018年09月20日","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"原地址在这里：自定义-Git-Git-钩子 Git钩子 # Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作\nGit钩子在哪? # 钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。\n把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用\n客户端钩子 # 提交工作流钩子、电子邮件工作流钩子和其它钩子\npre-commit # 钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit \u0026ndash;no-verify 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。\nprepare-commit-msg # prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。\ncommit-msg # commit-msg 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。\npost-commit # post-commit 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 git log -1 HEAD 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情\n电子邮件工作流钩子 # 你可以给电子邮件工作流设置三个客户端钩子。 它们都是由 git am 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。 如果你需要通过电子邮件接收由 git format-patch 产生的补丁，这些钩子也许用得上。\napplypatch-msg # 第一个运行的钩子是 applypatch-msg 。 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。\npre-applypatch # 下一个在 git am 运行期间被调用的是 pre-applypatch 。 有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。\npost-applypatch # post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程\n服务器端钩子 # 除了客户端钩子，作为系统管理员，你还可以使用若干服务器端的钩子对项目强制执行各种类型的策略。 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。\npre-receive # 处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。\nupdate # update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。\npost-receive # post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 pre-receive 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间\n","date":"2018年09月20日","externalUrl":null,"permalink":"/posts/git%E9%92%A9%E5%AD%90/","section":"Posts","summary":"","title":"Git钩子","type":"posts"},{"content":"","date":"2018年09月20日","externalUrl":null,"permalink":"/tags/%E9%92%A9%E5%AD%90/","section":"Tags","summary":"","title":"钩子","type":"tags"},{"content":" Gogs服务同博客静态服务在同一服务器，我想每次push后，Gogs接受成功后会自动更新远程服务器的资源\n用Hexo框架写完博客后，使用hexo d -g会将生成好的静态资源推送到自己的远程仓库，远程服务器每次都要登上去手动git pull，而写个crontab有又觉得不怎么好，然后就找到了Git 服务端钩子 post-receive此挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户\n这个钩子在Gogs的gogs-repositories目录下，每一个仓库目录下都有hooks/post-receive这个钩子，将以下改好后添加到文件内即可\nunset GIT_DIR NowPath=`pwd` DeployPath=\u0026#34;/var/www/blog\u0026#34; # 要将这里的路径修改为远程服务器上存放博客静态资源的目录 cd $DeployPath git pull origin master cd $NowPath exit 0 ","date":"2018年09月20日","externalUrl":null,"permalink":"/posts/%E5%90%91gogs%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%90%8E%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81/","section":"Posts","summary":"","title":"向Gogs仓库推送代码后，自动更新远程仓库的代码","type":"posts"},{"content":"","date":"2018年09月20日","externalUrl":null,"permalink":"/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","section":"Tags","summary":"","title":"自动部署","type":"tags"},{"content":" 这里列出了《Ruby 元编程》介绍的所用法术\n环绕别名 Around Alias # 从一个重新定义的方法中调用原始的、被重命名的版本\nclass String alias_method :old_reverse, :reverse def reverse \u0026#34;x#{old_reverse}x\u0026#34; end end \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;xcbax\u0026#39; 白板类 Blank Slate # 移除一个对象中的所有方法，以便吧他们转换成幽灵方法\nclass C def method_missing(name, *args) \u0026#34;#{name} is a ghost method\u0026#34; end end obj = C.new obj.to_s # =\u0026gt; \u0026#34;#\u0026lt;C:...\u0026gt;\u0026#34; class B \u0026lt; BasicObject def method_missing(name, *args) \u0026#34;#{name} is a ghost method\u0026#34; end end blank_slate = B.new blank_slate.to_s # =\u0026gt; \u0026#34;to_s is a ghost method\u0026#34; 类扩展 Class Extension # 通过向类的单件类中加入模块来定义类方法，是对象扩展的一个特例\nclass C end module M def a_method \u0026#39;a method\u0026#39; end end class \u0026lt;\u0026lt; C include M end C.a_method # =\u0026gt; \u0026#39;a method\u0026#39; 类实例变量 Class Instance Variable # 在一个Class对象的实例变量中存储类级别的状态\nclass C @my_class_instance_variable = \u0026#39;some value\u0026#39; def self.class_attribute @my_class_instance_variable end end C.class_attribute # =\u0026gt; \u0026#39;some value\u0026#39; 类宏 Class Macro # 在类定义中使用方法\nclass C end class \u0026lt;\u0026lt; C def a_method(arg) \u0026#34;a_method(#{arg} called)\u0026#34; end end class C a_method :x # =\u0026gt; \u0026#34;a_method(x) called\u0026#34; end 洁净室 Clean Room # 使用一个对象作为执行一个代码块的环境\nclass CleanRoom def a_userful_method x x * 2 end end CleanRoom.new.instance_eval { a_userful_method(3) } # =\u0026gt; 6 代码处理器 Code Processor # 处理从外部活的的代码字符串\nFile.readlines(\u0026#39;a_file_containing_lines_of_ruby.txt\u0026#39;).each do |line| puts \u0026#34;#{line.chomp} ==\u0026gt; #{eval(line)}\u0026#34; end # =\u0026gt; 1 + 1 ==\u0026gt; 2 # =\u0026gt; Math.log10(100) ==\u0026gt; 2.0 上下文探针 Context Probe # 执行一个代码块来获取一个对象上下文中的信息\nclass C def initialize @x = \u0026#39;a private instance variable\u0026#39; end end obj = C.new obj.instance_eval { @x } # =\u0026gt; \u0026#39;a private instance variable\u0026#39; 延迟执行 Deferred Evaluation # 在 proc 或 lambda 中存储一段代码及其上下文，用于以后执行\nclass C def store(\u0026amp;block) @my_code_capsule = block end def execute(*args) @my_code_capsule.call(*args) end end obj = C.new obj.store { $X = 1 } $X = 0 obj.execute $X # =\u0026gt; 1 动态派发 Dynamic Dispatch # 在运行是决定调用哪个方法\nmethod_to_call = :reverse obj = \u0026#39;abc\u0026#39; obj.send(method_to_call) # =\u0026gt; \u0026#39;reverse\u0026#39; 动态方法 Dynamic Method # 在运行是决定怎样定义一个方法\nclass C end C.class_eval do define_method :a_method do \u0026#39;a dynamic method\u0026#39; end end obj = C.new c.a_method # =\u0026gt; \u0026#39;a dynamic method\u0026#39; 动态代理 Dynamic Proxy # 把不能对应某个方法名的消息转发给另外一个对象\nclass MyDynamicProxy def initialize(target) @target = target end def method_missing(name, *args, \u0026amp;block) \u0026#34;result: #{@target.send(name, *args, \u0026amp;block)}\u0026#34; end end obj = MyDynamicProxy.new(\u0026#39;a string\u0026#39;) obj.reverse # =\u0026gt; \u0026#39;result: gnirts a\u0026#39; 扁平作用域 Flat Scope # 使用闭包在两个作用域之间共享变量\nclass C def an_attribute @attr end end obj = C.new a_variable = 100 obj.instance_eval do @attr = a_variable end obj.an_attribute # =\u0026gt; 100 幽灵方法 Ghost Method # 响应一个没有关联方法的消息\nclass C def method_missing(name, *args) name.to_s.reverse end end obj = C.new obj.my_ghost_method # =\u0026gt; \u0026#39;dohtem_tsohg_ym\u0026#39; 钩子方法 Hook Method # 复写一个方法来截获对象模型事件\n$INHERITORS = [] class C def self.inherited(subclass) $INHERITORS \u0026lt;\u0026lt; subclass end end class D \u0026lt; C end class E \u0026lt; D end class F \u0026lt; E end $INHERITORS # =\u0026gt; [D, E ,F] 内核方法 Kernel Method # 在Kernel模块中定义一个方法，使得所有对象都可使用\nmodule Kernel def a_method \u0026#39;a kernel method\u0026#39; end end a_method # =\u0026gt; \u0026#39;a kernel method\u0026#39; 惰性实例变量 Lazy Instance Variable # 等第一次访问一个实例变量时才对它进行初始化\nclass C def attribute @attribute = @attribute || \u0026#39;some value\u0026#39; end end obj = C.new obj.attribute # =\u0026gt; \u0026#39;some value\u0026#39; 拟态方法 Mimic Method # 把一个方法伪装成另外一种语言构件\ndef BaseClass name name == \u0026#39;string\u0026#39; ? String : Object end class C \u0026lt; BaseClass \u0026#39;string\u0026#39; # 一个看起像类的方法 attr_accessor :an_attribute # 一个看起像关键字的方法 end obj = C.new obj.an_attribute = 1 # 一个看起像属性的方法 猴子打补丁 Monkeypatch # 修改已有类的特性\n\u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;cba\u0026#39; class String def reverse \u0026#39;override\u0026#39; end end \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;override\u0026#39; 命名空间 Namespace # 在一个模块中定义常量，以防止命名冲突\nmodule MyNamespace class Array def to_s \u0026#39;to_a method in array of the my namespace\u0026#39; end end end Array.new.to_s # =\u0026gt; [] MyNamespace::Array.new.to_s # =\u0026gt; \u0026#39;to_a method in array of the my namespace\u0026#39; 空指针保护 Nil Guard # 用\u0026rsquo;||\u0026lsquo;操作符覆写一个空引用\nx = nil y = x || \u0026#39;a value\u0026#39; # =\u0026gt; \u0026#39;a value\u0026#39; 对象扩展 Object Extension # 通过一个对象的单件类混入模块来定义单件方法\nobj = Object.new module M def a_method \u0026#39;a singleton method in M\u0026#39; end end class \u0026lt;\u0026lt; obj include M end obj.a_method # =\u0026gt; \u0026#39;a singleton method\u0026#39; 打开类 Open Class # 修改已有的类\nclass String def a_method \u0026#39;a method\u0026#39; end end \u0026#39;abc\u0026#39;.a_method # =\u0026gt; \u0026#39;a method\u0026#39; 下包含包装器 Prepended Wrapper # 调用一个用 prepend 方式覆写的方法\nmodule M def reverse \u0026#34;x#{super}x\u0026#34; end end String.class_eval do prepend M end \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;xcbax\u0026#39; 细化 Refinement # 为类打补丁，作用范围仅到文件结束，或仅限于包含模块的作用域中\nmodule MyRefinement refine String do def reverse \u0026#39;refinement reverse\u0026#39; end end end \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;cba\u0026#39; using MyRefinement \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;refine reverse\u0026#39; 细化封装器 Refinement Wrapper # 在细化中调用非细化的方法\nmodule StringRefinement refine String do def reverse \u0026#34;x#{super}x\u0026#34; end end end using StringRefinement \u0026#39;abc\u0026#39;.reverse # =\u0026gt; \u0026#39;xcbax\u0026#39; 沙盒 Sandbox # 在一个安全的环境中执行未授权的代码\ndef sandbox \u0026amp;code proc do $SAFE = 2 yield end.call end begin sandbox { File.delete \u0026#39;a_file\u0026#39; } rescue Exception =\u0026gt; ex ex # =\u0026gt; end 作用域门 Scope Gate # 用class, module 或 def 关键字来隔离作用域\na = 1 defined? a # =\u0026gt; \u0026#39;local-variable\u0026#39; module MModule b = 1 defined? a # =\u0026gt; nil defined? b # =\u0026gt; \u0026#39;local-variable\u0026#39; end defined? a # =\u0026gt; \u0026#39;local-variable\u0026#39; defined? b # =\u0026gt; nil Self Yield # 把self传给当前代码块\nclass Person attr_accessor :name, :surname def initialize yield self end end joe = Person.new do |person| person.name = \u0026#39;Joe\u0026#39; person.surname = \u0026#39;Smith\u0026#39; end 共享作用域 Shared Scope # 在同一个扁平作用域的多个上下文中共享变量\nlambda do shared = 10 self.class_eval do defined_method :counter do shared end defined_method :down do shared -= 1 end end end.call counter # =\u0026gt; 10 3.times { down } counter # =\u0026gt; 7 单件方法 Singleton Method # 在一个对象上定义一个方法\nobj = \u0026#39;abc\u0026#39; class \u0026lt;\u0026lt; obj def obj_singleton_method \u0026#39;x\u0026#39; end end obj.obj_singleton_method # =\u0026gt; \u0026#39;x\u0026#39; 代码字符串 String of Code # 执行一段表示ruby代码的字符串\nstring_of_code = \u0026#39;1 + 1\u0026#39; eval(string_of_code) # =\u0026gt; 2 符号到Proc Symbol To Proc # 把一个调用单个方的块转换为一个符号\n(1..6).map(\u0026amp;:even?) # =\u0026gt; [false, true, false, true, false, true] ","date":"2018年09月20日","externalUrl":null,"permalink":"/posts/ruby%E5%85%83%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/","section":"Posts","summary":"","title":"Ruby元编程手册","type":"posts"},{"content":"","date":"2018年09月20日","externalUrl":null,"permalink":"/tags/%E5%85%83%E7%BC%96%E7%A8%8B/","section":"Tags","summary":"","title":"元编程","type":"tags"},{"content":" Jekyll 是一个简单的博客形态的静态站点生产机器\n准备工作 # 在本地使用Jekyll框架，需要电脑中已安装Git 、Ruby 安装Git # Windows：下载并安装 Git Mac：使用 Homebrew ：brew install git --with-gettext Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装Ruby # Ruby 有多个版本，建议使用rvm (Ruby Version Manager) 来管理Ruby的版本。对于windows小伙伴来说，建议使用Ruby安装程序 进行安装\n安装Ruby\n# 安装 Jekyll 需要 Ruby 版本 \u0026gt;= 2.1.0 rvm install 2.5.1 使用ruby-china的源镜像 # 替换 rvm 的配置信息 echo \u0026#34;ruby_url=https://cache.ruby-china.com/pub/ruby\u0026#34; \u0026gt; ~/.rvm/user/db 安装Jekyll # gem install bundler jekyll 国内小伙伴建议先使用ruby-china的Gem镜像 # 替换Gem源 gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ # 替换 Bundler 的 Gem 源代码镜像命令 bundle config mirror.https://rubygems.org https://gems.ruby-china.com 使用Jekyll # 初始化 # Jekyll new 博客文件夹 # 进入博客目录 cd 博客文件夹 # 安装依赖 bundle install 查看jekyll new更多帮助\njekyll new -h 本地启动 # # s 是 server jekyll s 然后在可以本地浏览器打开http://localhost:4000，就可以访问启动好的博客啦\n查看jekyll server更多帮助\njekyll s -h 使用Next主题 # 我使用的Next 主题\ngit clone https://github.com/Simpleyyt/jekyll-theme-next cd jekyll-theme-next bundle install jekyll s # 启动 此时项目目录就是jekyll-theme-next，修改项目目录下的_config.yml文件, 必须重启Hexo本地服务，即可在本地看到新的主题样式\n配置 # Jekyll大部份的的配置在项目目录下的_config.yml中，根据Jekyll官方文档 ，Jekyll中文文档 和Next文档 按照自己需要改动即可\n写文章 # 需要在_posts文件夹中创建一个新的文件，文件格式为年-月-日-标题.md，年是四位数字，月和日都是两位\n更多说明，参考Jekyll 写作 部署 # 部署的基本原理同Hexo的部署 , 但是Jekyll没有类与Hexo的hexo-deployer-git，所以需要手动把这静态资源的目录_site的中内容提交到远程就可以了\n","date":"2018年09月19日","externalUrl":null,"permalink":"/posts/jekyll%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/","section":"Posts","summary":"","title":"Jekyll的简单安装配置以及部署","type":"posts"},{"content":"","date":"2018年09月18日","externalUrl":null,"permalink":"/tags/%E9%9D%99%E6%80%81/","section":"Tags","summary":"","title":"静态","type":"tags"},{"content":" Nginx（发音同engine x）是一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存\n配置静态网站 # server { listen 80; # 端口号 server_name example.com; # 域名 location / { root /var/www/project_dir; # 静态项目路径 index index.html; # 网站初始页 error_page 404 /index.html; # 静态页面重定向服务器错误页面 } } 将以上配置存到一个文件中，然后编辑nginx.conf（使用nginx -t可以看到具体路径），用include 配置文件的路径;引入到配置中，退出编辑器，使用nginx -t来测试配置是否有误，有问题的改好后再进行下一步，使用nginx -s reload重新加载Nginx配置\n","date":"2018年09月18日","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","section":"Posts","summary":"","title":"使用Nginx部署静态网站","type":"posts"},{"content":"","date":"2018年09月17日","externalUrl":null,"permalink":"/tags/hexo/","section":"Tags","summary":"","title":"Hexo","type":"tags"},{"content":" Hexo是一个快速、简洁且高效的博客框架\n准备工作 # 在本地使用hexo框架，需要电脑中已安装Git 、Node.js 安装Git # Windows：下载并安装 Git Mac：使用 Homebrew ：brew install git --with-gettext Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core 安装Node.js # Node.js 有多个版本，建议使用nvm (Node Version Manager) 来管理node的版本。对于windows小伙伴来说，建议使用Node.js安装程序 进行安装，喜欢折腾的小伙伴可以试试nvm-windows 安装Node.js\nnvm install stable 使用淘宝的 Node.js 镜像 # nvm 使用镜像安装 NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install stable # windows小伙伴如果使用 nvm-windows，设置镜像 nvm node_mirror https://npm.taobao.org/mirrors/node/ 安装Hexo # npm install -g hexo-cli 国内小伙伴建议使用淘宝 NPM 镜像 # 安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org # 使用cnpm安装hexo cnpm install -g hexo-cli # windows小伙伴如果使用 nvm-windows，设置npm镜像 nvm npm_mirror https://npm.taobao.org/mirrors/npm/ 使用hexo # 初始化 # # --no-install 是使用初始\b化后跳过npm install hexo init 项目文件夹 --no-install # 进入项目目录 cd 项目文件夹 # 安装依赖 cnpm install 查看hexo init更多帮助\nhexo init -h 本地启动 # # s 是 server hexo s 然后会输出以下信息\nINFO Start processing INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 然后在可以本地浏览器打开http://localhost:4000，就可以访问启动好的博客啦\n查看hexo server更多帮助，也可参考Hexo 服务器 hexo s -h 安装Next主题 # 我使用的Next 主题\ncd 项目文件夹 git clone https://github.com/theme-next/hexo-theme-next themes/next 将项目目录下的_config.yml配置文件中的theme: landscape改为theme: next, 然后重启Hexo本地服务，即可在本地看到新的主题样式\n如果想改为其他主题，请前往Hexo Themes ，自行选取后，按照说明文档要求自行修改配置\n配置 # Hexo大部份的的配置在项目目录下的_config.yml中，根据Hexo官方文档 按照自己需要改动即可\n自己想个性化配置，例如在文章底部增加版权信息，网站底部字数统计等更多，可以参考Hexo的Next主题个性化配置教程 ，当然这个参考大部分都是next 5.x版本，新的版本还是建议参考theme-next 中的配置\n写文章 # 创建一个新的文章\nhexo new 文章名 更多说明，参考Hexo 写作 部署 # 安装hexo-deployer-git # 首先安装hexo-deployer-git cnpm install hexo-deployer-git --save 创建仓库 # 下面要用到git仓库，创建github.io仓库\n点击New repository 输入Repository name，必需为用户名.github.io格式 点击按钮Create repository 进入仓库用户名.github.io，点击Settings，找到GitHub Pages模块 点击Choose a theme选择一个页面主题 然后这个静态资源存放的远程仓库地址就创建了 指定仓库位置 # 下面将生成好的静态资源推到远程仓库，先修改博客项目目录下的_config.yml\ndeploy: type: git repo: 生成好的静态资源存放的远程仓库地址 branch: [分支名称] 部署 # 先生成文件后，再将静态资源提交到远程仓库\n# d 是 deploy # g 是 generate hexo g -d # 或者 hexo d -g 等个一会儿后，在浏览器打开https://用户名.github.io就可以访问博客网站了\n","date":"2018年09月17日","externalUrl":null,"permalink":"/posts/hexo%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/","section":"Posts","summary":"","title":"Hexo的安装配置以及部署","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]